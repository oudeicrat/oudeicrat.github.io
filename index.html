<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv=Content-Type content="text/html; charset=utf-8">
		<title>Flat Earth Map and Sun Position</title>
		<script type="text/javascript" src="lib/d3.js"></script>
		<script type="text/javascript" src="lib/d3.geo.projection.js"></script>
		<script type="text/javascript" src="celestial.js"></script>
		<link rel="stylesheet" href="celestial.css">
		
		<style type="text/css">
			body { font-family:Arial; font-size:12px; margin:0px; padding:0px; }
			input { font-family:Arial; font-size:12px; }
			button { font-family:Arial; font-size:12px; }
		</style>
		<script type="text/javascript">
			var d = null;
		
			//https://astronomy.stackexchange.com/questions/20560/how-to-calculate-the-position-of-the-sun-in-long-lat
			//Latitude of the Geographical Position (GP) is called Declination, and it is numerically equal 
			//to what one might call "Latitude". It is measured in degrees North or South the equator.
			//Longitude of the GP is called Greenwich Hour Angle (GHA)
			
			//http://answers.google.com/answers/threadview/id/782886.html
			//https://gist.github.com/jgomezdans/733741/
			
			var ctx = null;
			var showObserver = true;
			var showStars = false;
			var showDaylight = true;
			
			var doAnimateTime = false;
			var animateTimeout = null;
			var animateTimeInterval = 1; //add 2 minutes to reference UTC datetime
			//var animateTimeInterval = 60*24; //add 1 day to reference UTC datetime
			
			var animateTimePeriod = 100; //50ms framerate
			
			var showEquatorCheckpoints = false;
			var showSouthCheckpoints = false;
			var showNorthCheckpoints = false;
			var showFlatDirection = false;
			
			var canvasSize;
			var halfCanvas;
			var canvasSizeReciprocal;
			var m180divPI = 180/Math.PI;
			var rec180 = 1/180;
			
			var userLat = 0.00;
			var userLng = 0.00;
			var previousLat = 0.00;
			var previousLng = 0.00;
			var localGmtOffset = 0;
			var minutesOffset = 0;
			var declination = 0;
			var goingToRequest = false;
			var requestWaitTimeout = null;
			var year = new Date().getFullYear(); 
			
			var routeStartX = null;
			var routeStartY = null;
			var routeStartLat = null;
			var routeStartLng = null;
			var routeEndLat = null;
			var routeEndLng = null;

			function drawMap() {
				if (ctx===null) return false;
				var imageObj = document.getElementById('mapimg');
				
				ctx.globalAlpha = 0.5;
				ctx.drawImage(imageObj, 0, 0,canvasSize,canvasSize);
				ctx.globalAlpha = 1;
			}
			
			function gpsToMapXY(lat,lng) {
				var y = Math.round(canvasSize/2+(90-lat)/360*canvasSize*Math.cos(-lng/180*Math.PI));
				var x = Math.round(canvasSize/2+(lat-90)/360*canvasSize*Math.sin(-lng/180*Math.PI));
				return {x,y};
			}
			function xyToGps(x,y) {
				var rx = 2.0*x * canvasSizeReciprocal - 1.0;
				var ry = 2.0*y * canvasSizeReciprocal - 1.0;
				var r = Math.sqrt(rx*rx + ry*ry);
				if (r > 0.99) return false;

				var lat = 90-180*r;
				var lng = 0;
				if (ry > 0.0) {
					lng = Math.atan(rx/ry) * m180divPI;
				} else if (ry < 0.0) {
					if (rx>=0.0) lng = 180 - Math.atan(rx/(-ry)) * m180divPI;
					else lng = -180 - Math.atan(rx/(-ry)) * m180divPI;
				} else {
					if (rx>=0.0) lng = 90;
					else lng = -90;
				}
				return {'lat':lat,'lng':lng};
			}
			function drawDot(lat, lng, radius, color) {
				ctx.fillStyle = color;
				ctx.beginPath();
				coord = gpsToMapXY(lat,lng);
				ctx.lineWidth = 1;
				ctx.arc(coord.x, coord.y, radius, 0, 2*Math.PI, true);
				ctx.strokeStyle = color;
				ctx.stroke();
				ctx.fill();
			}
			
			function drawSun(lat,lng) {
				if (ctx===null) return false;
				ctx.fillStyle = '#fd0';
				ctx.beginPath();
				coord = gpsToMapXY(lat,lng);
				ctx.lineWidth = 2;
				ctx.arc(coord.x, coord.y, 10, 0, 2*Math.PI, true); //3rd param = radius
				ctx.strokeStyle = '#fb0';
				ctx.stroke();
				if (!showStars) ctx.fill();
			}
			function drawCompassGps(lat,lng,color,radius,thickness) {
				if (ctx===null) return false;
				coord = gpsToMapXY(lat,lng);
				ctx.beginPath();
				ctx.lineWidth = 1;
				ctx.strokeStyle = '#ccc';
				
				ctx.moveTo(coord.x, coord.y);
				ctx.lineTo(halfCanvas,halfCanvas);
				ctx.stroke();

				ctx.beginPath();
				ctx.lineWidth = thickness;
				ctx.strokeStyle = color;
				
				ctx.moveTo(coord.x - Math.sin(rad(lng))*radius, coord.y - Math.cos(rad(lng))*radius);
				ctx.lineTo(coord.x + Math.sin(rad(lng))*radius, coord.y + Math.cos(rad(lng))*radius);
				ctx.stroke();
				
				ctx.moveTo(coord.x - Math.cos(rad(lng))*radius, coord.y + Math.sin(rad(lng))*radius);
				ctx.lineTo(coord.x + Math.cos(rad(lng))*radius, coord.y - Math.sin(rad(lng))*radius);
				ctx.stroke();
				
				ctx.beginPath();
				ctx.lineWidth = 1;
				ctx.moveTo(coord.x - Math.cos(rad(lng))*3, coord.y + Math.sin(rad(lng))*3);
				ctx.lineTo(coord.x - Math.sin(rad(lng))*radius, coord.y - Math.cos(rad(lng))*radius);
				ctx.lineTo(coord.x + Math.cos(rad(lng))*3, coord.y - Math.sin(rad(lng))*3);
				ctx.stroke();

				ctx.font = '14px Arial';
				ctx.fillStyle = color;
				ctx.fillText('N', Math.round(coord.x - Math.sin(rad(lng))*radius*2 - 4), Math.round(coord.y - Math.cos(rad(lng))*radius*2 + 6) );
				
			}
			function drawArrow(lat,lng,pos,lineWidth,arrowSize,color,elongationPattern) {
				if (ctx===null) return false;
				var arrowDirection = null;
				var arrowX = null;
				var arrowY = null;
				
				var coord = gpsToMapXY(lat,lng);
				
				if (typeof pos === 'number') { //pos = AZ
					arrowDirection = pos - lng; //because AZ is relative to observer
					arrowX = coord.x + Math.sin(rad(arrowDirection)) * arrowSize;
					arrowY = coord.y - Math.cos(rad(arrowDirection)) * arrowSize;
					
				} else if ( //pos = lat,lng
					typeof pos === 'object' && 
					typeof pos.lat === 'number' && 
					typeof pos.lng === 'number'
				) {
					var arrowEndpoint = gpsToMapXY(pos.lat,pos.lng);
					arrowX = arrowEndpoint.x;
					arrowY = arrowEndpoint.y;
				}
			
				ctx.lineWidth = lineWidth;
				ctx.strokeStyle = color; //'#f32';
				ctx.beginPath();
				
				ctx.moveTo(coord.x, coord.y);
				ctx.lineTo(arrowX, arrowY);
				ctx.stroke();
				
				var arrowAngle = 12;
				var arrowLength = Math.round(2*arrowSize / 3); 
				
				ctx.moveTo(arrowX, arrowY);
				ctx.lineTo(coord.x + Math.sin(rad(arrowDirection+arrowAngle)) * arrowLength, coord.y - Math.cos(rad(arrowDirection+arrowAngle)) * arrowLength);
				ctx.stroke();
				
				ctx.moveTo(arrowX, arrowY);
				ctx.lineTo(coord.x + Math.sin(rad(arrowDirection-arrowAngle)) * arrowLength, coord.y - Math.cos(rad(arrowDirection-arrowAngle)) * arrowLength);
				ctx.stroke();

				if (elongationPattern!==false && elongationPattern!==null) {
					ctx.setLineDash(elongationPattern);
					ctx.lineWidth = 1;
					ctx.moveTo(coord.x, coord.y);
					arrowSize = canvasSize; //TODO: limit to the edge of canvas
					ctx.lineTo(coord.x + Math.sin(rad(arrowDirection)) * arrowSize, coord.y - Math.cos(rad(arrowDirection)) * arrowSize);
					ctx.stroke();
					ctx.setLineDash([]);
				}
			}
			
			function rad(deg) { return deg * Math.PI * rec180; } 
			
			var difRadLat = null;
			var difRadLng = null;
			var radLat1 = null;
			var radLng1 = null;
			var radLat2 = null;
			var radLng2 = null;
			var angDist = null;
			//http://www.movable-type.co.uk/scripts/latlong.html
			function getAngularDistance(lat1, lng1, lat2, lng2) {
				radLat1 = rad(lat1); //φ1
				radLng1 = rad(lng1); //λ1
				radLat2 = rad(lat2); //φ2
				radLng2 = rad(lng2); //λ2
				difRadLat = radLat2 - radLat1; //Δφ
				difRadLng = radLng2 - radLng1; //Δλ
				var halfChordSquared = Math.sin(difRadLat/2) * Math.sin(difRadLat/2) + 
					Math.cos(radLat1) * Math.cos(radLat2) * 
					Math.sin(difRadLng/2) * Math.sin(difRadLng/2);
				var result = 2 * Math.atan2(Math.sqrt(halfChordSquared), Math.sqrt(1-halfChordSquared));
				angDist = result;
				return result;
			}
			function getFracPoint(frac) { //based on the last call of getAngularDistance(), f=0..1
				var A = Math.sin((1-frac)*angDist) / Math.sin(angDist);
				var B = Math.sin(frac*angDist) / Math.sin(angDist);
				
				var x = A * Math.cos(radLat1) * Math.cos(radLng1) + B * Math.cos(radLat2) * Math.cos(radLng2);
				var y = A * Math.cos(radLat1) * Math.sin(radLng1) + B * Math.cos(radLat2) * Math.sin(radLng2);
				var z = A * Math.sin(radLat1) + B * Math.sin(radLat2);
			
				return { 
					lat:m180divPI * Math.atan2(z, Math.sqrt(x*x + y*y)), 
					lng:m180divPI * Math.atan2(y, x) 
				};
			}
			
			function isSunVisible(observer,htcOffset,sinDecl,cosDecl) {
				//htcOffset = (h-12)*15 + TC
				//sinDecl = Math.sin(rad(Decl));
				//cosDecl = Math.cos(rad(Decl));
				var SHArto = htcOffset + observer.lng;  
				if (SHArto > 180) {
					SHArto = SHArto - 360;
				} else if (SHArto < -180) {
					SHArto = SHArto + 360;
				}
				
				var cosSZA = Math.sin(rad(observer.lat)) * sinDecl + Math.cos(rad(observer.lat)) * cosDecl * Math.cos(rad(SHArto));
				//cosSZA < 0 = sun is below horizon
				//cosSZA > 0 = sun is visible above horizon
				return cosSZA;
			}
			
			function getSunPos(d,observer) {
				//https://gist.github.com/jgomezdans/733741/
				
				year = d.getUTCFullYear();
				var startDate = new Date(Date.UTC(year,0,1,0,0,0));
				var doy = 1 + Math.floor((d - startDate) / (1000 * 60 * 60 * 24));
				//console.log('doy = ',doy);
				var h = d.getUTCHours() + d.getUTCMinutes()/60; //absolute value (not relative to observer)
				//console.log('h = ',h);
				//gdeg = (360/365.25)*(doy+ h/24)
				//g = radians(gdeg)
				var g = (2/365.25)*(doy + h/24)*Math.PI;
				//console.log('g(rad) = ',g);
				//console.log('g(deg) = ',g*180/Math.PI);
				//declination = sun Geographical Position latitude (absolute)
				var Decl = 0.396372-22.91327*Math.cos(g)+4.02543*Math.sin(g)-0.387205*Math.cos(2*g) 
					+ 0.051967*Math.sin(2*g)-0.154527*Math.cos(3*g) + 0.084798*Math.sin(3*g);
				//console.log('Decl = ',Decl);
				//solar angle time correction
				var TC = 0.004297+0.107029*Math.cos(g)-1.837877*Math.sin(g) - 0.837378*Math.cos(2*g) - 2.340475*Math.sin(2*g);
				//console.log('TC = ',TC);
				//Solar Hour Angle relative to observer SHArto = (hour-12)*15 + Longitude + TC
				var htcOffset = (h-12)*15 + TC;
				var SHArto = htcOffset + observer.lng;  
				if (SHArto > 180) {
					SHArto = SHArto - 360;
				} else if (SHArto < -180) {
					SHArto = SHArto + 360;
				}
				//console.log('userLng(deg) = ',userLng);
				//console.log('SHA relative to observer (deg) = ',SHArto);
				//absolute SHA = absolute sun Geographical Position longitude
				var SHAa = (12-h)*15 - TC;  
				if (SHAa > 180) {
					SHAa = SHAa - 360;
				} else if (SHAa < -180) {
					SHAa = SHAa + 360;
				}
				//console.log('absolute SHA (deg) = ',SHAa);
				
				//zenith (relative to observer)
				//cos(SZA) = sin(Latitude)*sin(Decl)+cos(Latitude)*cos(Decl)*cos(SHA)
				var sinDecl = Math.sin(rad(Decl));
				var cosDecl = Math.cos(rad(Decl));
				var cosSZA = Math.sin(rad(observer.lat)) * sinDecl + Math.cos(rad(observer.lat)) * cosDecl * Math.cos(rad(SHArto));
				//cosSZA < 0 = sun is below horizon
 				if (cosSZA > 1.00) cosSZA = 1.00;
 				if (cosSZA < -1.00) cosSZA = -1.00;
 				//console.log('cosSZA = ',cosSZA);
 				var SZArad = Math.acos(cosSZA);
 				//console.log('SZArad = ',SZArad);
 				var SZA = SZArad * m180divPI; //zenith>90 = sun is below horizon
 				//console.log('SZA = ',SZA);
   
				//azimuth (relative to observer)
				//cos(AZ) = (sin(Decl)-sin(Latitude)*cos(SZA))/(cos(Latitude)*sin(SZA))
				var cosAZ = (Math.sin(rad(Decl)) - Math.sin(rad(observer.lat)) * Math.cos(SZArad)) / (Math.cos(rad(observer.lat)) * Math.sin(SZArad));
 				if (cosAZ > 1.00) cosAZ = 1.00;
 				if (cosAZ < -1.00) cosAZ = -1.00;
 				//console.log('cosAZ = ',cosAZ);
				var AZ = Math.acos(cosAZ) * m180divPI;
				if (SHArto>0) AZ = 360 - AZ; //https://en.wikipedia.org/wiki/Solar_azimuth_angle#Formulas "...between 180 and 360 degrees when the hour angle is positive (afternoon)"
				//console.log('AZ = ',AZ);
				
				return {'lat':Decl, 'lng':SHAa, 'az':AZ, 'zen':SZA, 'htcOffset':htcOffset, 'sinDecl':sinDecl, 'cosDecl':cosDecl }; //lat,lng = absolute; az,zen = relative to observer  
			}
			
			//compare to: https://www.timeanddate.com/worldclock/sunearth.html
			
			
			function outputUTCDateTime(d) {
				year = d.getUTCFullYear();
				document.getElementById('dateTimeInput').value = year + '-' + String('0'+(d.getUTCMonth()+1)).slice(-2)
					+ '-' + String('0'+d.getUTCDate()).slice(-2) + ' ' + String('0'+d.getUTCHours()).slice(-2) + ':' 
					+ String('0'+d.getUTCMinutes()).slice(-2); // + ':' + String('0'+d.getUTCSeconds()).slice(-2);
			}

			function updateAzimuthCheckLink(d, localGmtOffset) {
				var localDate = new Date(d.getTime() + localGmtOffset);
				
				document.getElementById('azimuthCheckLink').href = 'https://www.suncalc.org/#/'
					+ (Math.round(userLat*100)/100) + ',' + (Math.round(userLng*100)/100) + ',2/'
					+ localDate.getUTCFullYear()+'.'+String('0'+(localDate.getUTCMonth()+1)).slice(-2)+'.'+String('0'+localDate.getUTCDate()).slice(-2)
					+ '/' + String('0'+localDate.getUTCHours()).slice(-2) + ':' + String('0'+localDate.getUTCMinutes()).slice(-2) + '/1/0';
			}
			
			function showAltSunPos(d) {
				var altPos = [
					{'pos':{'lat':0.0,'lng':-150},'cat':0},
					{'pos':{'lat':0.0,'lng':-120},'cat':0},
					{'pos':{'lat':0.0,'lng':-90},'cat':0},
					{'pos':{'lat':0.0,'lng':-60.0},'cat':0},
					{'pos':{'lat':0.0,'lng':-30.0},'cat':0},
					{'pos':{'lat':0.0,'lng':0.0},'cat':0},
					{'pos':{'lat':0.0,'lng':30.0},'cat':0},
					{'pos':{'lat':0.0,'lng':60.0},'cat':0},
					{'pos':{'lat':0.0,'lng':90},'cat':0},
					{'pos':{'lat':0.0,'lng':120.0},'cat':0},
					{'pos':{'lat':0.0,'lng':150.0},'cat':0},
					{'pos':{'lat':0.0,'lng':180},'cat':0},

					{'pos':{'lat':-60.0,'lng':-150},'cat':-60},
					{'pos':{'lat':-60.0,'lng':-120},'cat':-60},
					{'pos':{'lat':-60.0,'lng':-90},'cat':-60},
					{'pos':{'lat':-60.0,'lng':-60.0},'cat':-60},
					{'pos':{'lat':-60.0,'lng':-30.0},'cat':-60},
					{'pos':{'lat':-60.0,'lng':0.0},'cat':-60},
					{'pos':{'lat':-60.0,'lng':30.0},'cat':-60},
					{'pos':{'lat':-60.0,'lng':60.0},'cat':-60},
					{'pos':{'lat':-60.0,'lng':90},'cat':-60},
					{'pos':{'lat':-60.0,'lng':120.0},'cat':-60},
					{'pos':{'lat':-60.0,'lng':150.0},'cat':-60},
					{'pos':{'lat':-60.0,'lng':180},'cat':-60},
					
					{'pos':{'lat':60.0,'lng':-150},'cat':60},
					{'pos':{'lat':60.0,'lng':-120},'cat':60},
					{'pos':{'lat':60.0,'lng':-90},'cat':60},
					{'pos':{'lat':60.0,'lng':-60.0},'cat':60},
					{'pos':{'lat':60.0,'lng':-30.0},'cat':60},
					{'pos':{'lat':60.0,'lng':0.0},'cat':60},
					{'pos':{'lat':60.0,'lng':30.0},'cat':60},
					{'pos':{'lat':60.0,'lng':60.0},'cat':60},
					{'pos':{'lat':60.0,'lng':90},'cat':60},
					{'pos':{'lat':60.0,'lng':120.0},'cat':60},
					{'pos':{'lat':60.0,'lng':150.0},'cat':60},
					{'pos':{'lat':60.0,'lng':180},'cat':60},
					
					//{'pos':{'lat':,'lng':},'cat':''},
					//{'pos':{'lat':,'lng':},'cat':''},
					//{'pos':{'lat':,'lng':},'cat':''},
					//{'pos':{'lat':,'lng':},'cat':''},
					//{'pos':{'lat':,'lng':},'cat':''},
					//{'pos':{'lat':,'lng':},'cat':''},
					//{'pos':{'lat':-31.95,'lng':115.86},'cat':'Perth'},
					//{'pos':{'lat':40.72,'lng':-74.0},'cat':'New York'},
					//{'pos':{'lat':51.51,'lng':-0.13},'cat':'London'}
				];
				for (var i in altPos) {
					if (
						(altPos[i].cat == 0 && showEquatorCheckpoints) ||
						(altPos[i].cat == -60 && showSouthCheckpoints) ||
						(altPos[i].cat == 60 && showNorthCheckpoints)
					) {
						var altSunPos = getSunPos(d,altPos[i].pos);
						if (altSunPos.zen > 100) { //sun below horizon (>90 + padding)
							//drawCompassGps(altPos[i].pos.lat, altPos[i].pos.lng, '#000', 8, 1);
						} else { //sun above horizon
							drawArrow(altPos[i].pos.lat, altPos[i].pos.lng, altSunPos.az, 1, 20, '#000', [2,10]);
							//drawCompassGps(altPos[i].pos.lat, altPos[i].pos.lng, '#000', 8, 1);
						}
					}
					
				}

			}
			
			function drawNight(htcOffset, sinDecl, cosDecl) {
				if (ctx===null) return false;
				//isSunVisible(testPosition, htcOffset, sinDecl, cosDecl);
				
				//canvasRadius = canvasSize/2;
				//canvasRadiusSquared = canvasSize*canvasSize/4;
				var tileSize = 6;
				var halfTileSize = 3;
				var visibility = -1;
				var pos = false;
				var drawNightSegment = false;
				var fillAlpha = 1;
				
				for (var x=0; x<canvasSize; x+=tileSize) {
					for (var y=0; y<canvasSize; y+=tileSize) {
						pos = xyToGps(x,y);
						if (pos !== false) {
							visibility = isSunVisible(pos, htcOffset, sinDecl, cosDecl);
							drawNightSegment = true;
							//ctx.globalAlpha = 1;
							fillAlpha = 1;
							if (visibility > 0.1) {
								drawNightSegment = false;
								//if (visibility > 0.85) {
								//	ctx.globalAlpha = (visibility-0.84)*2;
								//	ctx.fillStyle = '#ff0';
								//	ctx.beginPath();
								//	ctx.rect(x-halfTileSize, y-halfTileSize, tileSize, tileSize);
								//	ctx.fill();
								//}
							} else if (visibility > -0.2) {
								fillAlpha = 1-(visibility+0.2)*3.33;
								//ctx.globalAlpha = fillAlpha;
							}
							
							if (drawNightSegment) {
								//ctx.fillStyle = '#000';
								ctx.fillStyle = "rgba(0,0,0,"+fillAlpha+")";
								ctx.beginPath();
								ctx.rect(x-halfTileSize, y-halfTileSize, tileSize, tileSize);
								ctx.fill();
							}
						}
					}
				}
				//ctx.globalAlpha = 1;
			}
			//------------------------------------------------------------------
			
			function redraw(allowAnimation) {
				if (ctx===null) return false;
				if (typeof allowAnimation === 'undefined' || true !== allowAnimation) allowAnimation = false;
				if (!allowAnimation && doAnimateTime) return;
			
				if (animateTimeout!==null) clearTimeout(animateTimeout);
				//console.log('redraw called');
				
				ctx.fillStyle = '#fff';
				ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
				
				var parsedUserLocation = /^(-?[0-9]+(?:.[0-9]+)?)[\s,;]+(-?[0-9]+(?:.[0-9]+)?)$/.exec(document.getElementById('latLongInput').value);
				if (
					//typeof parsedUserLocation != 'null' &&
					typeof parsedUserLocation != 'undefined' &&
					parsedUserLocation != null &&
					//parsedUserLocation != false &&
					'1' in  parsedUserLocation &&
					'2' in  parsedUserLocation &&
					typeof parsedUserLocation[1] != 'undefined' &&  
					typeof parsedUserLocation[2] != 'undefined' &&
					'NaN' != parseFloat(parsedUserLocation[1]) &&
					'NaN' != parseFloat(parsedUserLocation[2])
				) {
					userLat = Math.round(parseFloat(parsedUserLocation[1])*100)/100;
					userLng = Math.round(parseFloat(parsedUserLocation[2])*100)/100;
					
					if (userLat != 'NaN' && userLng != 'NaN')
						document.getElementById('latLongInput').value = (Math.round(userLat*100)/100) + ', ' + (Math.round(userLng*100)/100);
				} else {
					alert('unknown GPS format, use -12.34, 56.78');
				}
				
				var parsedDate = /^([0-9]{4})[-]([0-9]{1,2})[-]([0-9]{1,2})(?:[ ]([0-9]{1,2})[:]([0-9]{1,2})(?:[:]([0-9]{1,2}))?)?$/.exec(document.getElementById('dateTimeInput').value);
				if (
					typeof parsedDate != 'undefined' &&
					parsedDate != null &&
					'1' in parsedDate &&
					'2' in parsedDate &&
					'3' in parsedDate &&
					typeof parsedDate[1] != 'undefined' &&  
					typeof parsedDate[2] != 'undefined' &&
					typeof parsedDate[3] != 'undefined' &&
					'NaN' != parseInt(parsedDate[1]) &&
					'NaN' != parseInt(parsedDate[2]) &&
					'NaN' != parseInt(parsedDate[3])
				) {
					if (!('4' in parsedDate) || typeof parsedDate[4] == 'undefined' || 'NaN'==parseInt(parsedDate[4])) parsedDate[4] = 0; 
					if (!('5' in parsedDate) || typeof parsedDate[5] == 'undefined'  || 'NaN'==parseInt(parsedDate[5])) parsedDate[5] = 0; 
					if (!('6' in parsedDate) || typeof parsedDate[6] == 'undefined'  || 'NaN'==parseInt(parsedDate[6])) parsedDate[6] = 0; 
				
					d = new Date(Date.UTC(
						parseInt(parsedDate[1]),
						parseInt(parsedDate[2])-1,
						parseInt(parsedDate[3]),
						parseInt(parsedDate[4]),
						parseInt(parsedDate[5]),
						parseInt(parsedDate[6]),
					));
				}
				
				if (d === null || d == 'Invalid Date' || d == 'NaN') { //use current time if no valid value entered
					d = new Date(); //browser datetime in the timezone of the browser
					localGmtOffset = d.getTimezoneOffset()*60000;
				}
				
				outputUTCDateTime(d);
				
				if (showStars) {
					//Celestial.rotate({center:[0,90,0]});
					//Celestial.date(d);
					Celestial.skyview({date:d});
					document.getElementById('celestialDiv').style.display = 'block';
					
					//suns overlap around 2019-05-07 18:00
					
					
					// !!!     !!!     !!!     !!!     !!!     !!!     !!!     !!!
					// !!!     !!!     !!!     !!!     !!!     !!!     !!!     !!!
					//
					//                   sky must be inverted
					//
					// !!!     !!!     !!!     !!!     !!!     !!!     !!!     !!!
					// !!!     !!!     !!!     !!!     !!!     !!!     !!!     !!!
					//The sky is currently rendered as if the observer was looking at 
					//it from the surface. We however need the stars to be rendered
					//as a projection on the surface, ie. every star at the location 
					//it is visible from directly overhead 
					
					
					
					//console.log('outside container: ',Celestial.container);
					/*
					Celestial.container.selectAll('.planet').each(function(d) {
						var id = d.id();
						if (id=='sol') {
							var dt = Celestial.date(), o = Celestial.origin(dt).spherical();
							var p = d(dt).equatorial(o);
							//var pt = Celestial.prjMap(p.pos);
							//console.log(p);
						}
					});/* */
					//Celestial.skyview({date:d, location:[0, 90]});
				}
				

				var sunPos = getSunPos(d,{'lat':userLat,'lng':userLng});
				if (showDaylight) {
					drawNight(sunPos.htcOffset, sunPos.sinDecl, sunPos.cosDecl);
				} else {
					//darken the whole map so stars are visible
					ctx.fillStyle = '#000';
					var halfCanvas = Math.round(canvasSize/2);
					ctx.arc(halfCanvas, halfCanvas, halfCanvas, 0, 2*Math.PI, true);
					ctx.fill();				
				}
				drawMap();
				drawSun(sunPos.lat, sunPos.lng);
				
				if (sunPos.lat != 'NaN' && sunPos.lng != 'NaN')
					document.getElementById('latLongOutput').value = Math.round(sunPos.lat*100)/100 + ', ' + Math.round(sunPos.lng*100)/100;
				if (sunPos.zen != 'NaN' && sunPos.az != 'NaN')
					document.getElementById('zenAzOutput').value = Math.round(sunPos.zen*100)/100 + ', ' + Math.round(sunPos.az*100)/100;
				if (showObserver) {
					if (sunPos.zen > 100) { //sun below horizon (>90 + padding)
						drawCompassGps(userLat, userLng, '#000', 13, 2);
						document.getElementById('dayCaption').style.display = 'none';
						document.getElementById('nightCaption').style.display = 'inline';
					} else { //sun above horizon
						drawArrow(userLat, userLng, sunPos.az, 3, 50, '#f32', [8,4]);
						drawCompassGps(userLat, userLng, '#000', 13, 2);
						document.getElementById('dayCaption').style.display = 'inline';
						document.getElementById('nightCaption').style.display = 'none';
					}
				} else {
					document.getElementById('dayCaption').style.display = 'none';
					document.getElementById('nightCaption').style.display = 'none';
				}
				if (showFlatDirection) {
					drawArrow(userLat, userLng, sunPos, 1, 0, '#090', false);
				}
				
				showAltSunPos(d);
				
				document.getElementById('sunPosCheckLink').href = 'https://www.timeanddate.com/worldclock/sunearth.html?month='
					+ (d.getUTCMonth()+1) + '&day=' + d.getUTCDate() + '&year=' + d.getUTCFullYear() + '&hour='
					+ d.getUTCHours() + '&min=' + d.getUTCMinutes() + '&ntxt=London';
					
				if (
					Math.round(10*previousLat)/10 != Math.round(10*userLat)/10 || 
					Math.round(10*previousLng)/10 != Math.round(10*userLng)/10
				) {
					document.getElementById('azimuthCheckLink').href = 'https://www.suncalc.org/';
					if (goingToRequest) {
						clearTimeout(requestWaitTimeout);
						goingToRequest = false;
						//console.log('clearing request timeout');
					}
					goingToRequest = true;
					//console.log('setting up request timeout');
					requestWaitTimeout = setTimeout(function(){
						goingToRequest = false;	
						var xhr = new XMLHttpRequest();
						xhr.onload = function() {
							if (this.readyState == 4 && this.status == 200) {
								var jsonData = JSON.parse(this.responseText);
								if ('status' in jsonData && jsonData.status=='OK' && 'gmtOffset' in jsonData) {
									localGmtOffset = jsonData.gmtOffset*1000; //eg. GMT+1 -> jsonData.gmtOffset = 3600
									
									updateAzimuthCheckLink(d, localGmtOffset);

								} else {
									//console.log('timezonedb.com request unsuccessful');
									//sometimes timezone is not found (for example in the ocean)
								}
							} else { alert('requesting timezonedb.com failed'); }
							previousLat = userLat; previousLng = userLng;
						};
						var timeZoneDbUrl = 'https://api.timezonedb.com/v2.1/get-time-zone?key=H57PYG9KKM6P&format=json&by=position&lat='
							+ (Math.round(userLat*100)/100) + '&lng=' + (Math.round(userLng*100)/100);
						
						xhr.open('get', timeZoneDbUrl);
						//console.log('requesting timezonedb.com');
						xhr.send();
						
						
					},1200);
				} else {
					updateAzimuthCheckLink(d, localGmtOffset)
				}
				
				if (doAnimateTime) {
					d = new Date(d.getTime() + animateTimeInterval*60000); //add animateTimeInterval minutes
					outputUTCDateTime(d);
					if (animateTimeout!==null) clearTimeout(animateTimeout);
					animateTimeout = setTimeout('redraw(true);',animateTimePeriod);
				}
			} //redraw
			//------------------------------------------------------------------
			
			function setMarchEquinox() {
				document.getElementById('dateTimeInput').value = year+'-03-20 03:00';
				setTimeout('redraw();',10);
				return false;
			}
			function setJuneSolstice() {
				document.getElementById('dateTimeInput').value = year+'-06-20 20:00';
				setTimeout('redraw();',10);
				return false;
			}
			function setSeptemberEquinox() {
				document.getElementById('dateTimeInput').value = year+'-09-22 05:00';
				setTimeout('redraw();',10);
				return false;
			}
			function setDecemberSolstice() {
				document.getElementById('dateTimeInput').value = year+'-12-21 05:00';
				setTimeout('redraw();',10);
				return false;
			}
			function setMonth(monthNumber) {
				if (monthNumber < 10) monthNumber = '0'+monthNumber;
				document.getElementById('dateTimeInput').value = document.getElementById('dateTimeInput').value.replace(/^([0-9]+[-])[0-9]+([-].+)$/,'$1'+monthNumber+'$2');
				setTimeout('redraw();',10);
				return false;
			}
			//------------------------------------------------------------------

			var celestialConfig = {
			    zoomlevel: 0.511,
			    location: false,
			    //follow: 'center',
			    projection: "azimuthalEquidistant",
			    center: [0,90,0],       // Initial center coordinates in equatorial transformation [hours (lon), degrees (lat), degrees],
			    geopos: [90,0], //lat,lon
			    container: "celestialDiv",   // ID of parent element, e.g. div
			    datapath: "celestialdata/",  // Path/URL to data files, empty = subfolder 'data'
			
			    //orientationfixed: true,  // Keep orientation angle the same as center[2]
			    //adaptable: true,    // Sizes are increased with higher zoom-levels
			    interactive: false,  // Enable zooming and rotation with mousewheel and dragging
			    form: false,        // Display settings form
			    controls: false,     // Display zoom controls
			
			    planets: {
			        show: true,
			        which: ["sol", "mer", "ven", "ter", "lun", "mar", "jup", "sat", "ura", "nep"],
			        style: { fill: "#00ccff", font: "bold 17px 'Lucida Sans Unicode', Consolas, sans-serif", align: "center", baseline: "middle" },
			        symbols: {  // Character and color for each symbol in 'which', simple circle \u25cf
			            "sol": {symbol: "\u2609", fill: "#ffff00"},
			            "mer": {symbol: "\u263f", fill: "#cccccc"},
			            "ven": {symbol: "\u2640", fill: "#eeeecc"},
			            "ter": {symbol: "\u2295", fill: "#00ffff"},
			            "lun": {symbol: "\u25cf", fill: "#ffffff"}, // overridden by generated cresent
			            "mar": {symbol: "\u2642", fill: "#ff9999"},
			            "cer": {symbol: "\u26b3", fill: "#cccccc"},
			            "ves": {symbol: "\u26b6", fill: "#cccccc"},
			            "jup": {symbol: "\u2643", fill: "#ff9966"},
			            "sat": {symbol: "\u2644", fill: "#ffcc66"},
			            "ura": {symbol: "\u2645", fill: "#66ccff"},
			            "nep": {symbol: "\u2646", fill: "#6666ff"},
			            "plu": {symbol: "\u2647", fill: "#aaaaaa"},
			            "eri": {symbol: "\u25cf", fill: "#eeeeee"}
			        },
			    },
			    stars: {
			    	show: true,
					names: false, 
					limit: 4.6
				},
			    dsos: {show: false},
				mw: { show: false},
			    constellations: {
			    	show: true,
					names: true,
				},
				horizon: { show: false },
				daylight: { show: false }, 
			    lines: {
			        graticule: { show: false },
					equatorial: { show: false, stroke: "#9a8", width: 1.3, opacity: 0.7 },
					ecliptic: { show: true, stroke: "#66cc66", width: 1.1, opacity: 0.4, dash: [5, 4] },
			    },
			    background: { fill: "#fff", stroke: "#fff", opacity: 0.01, width: 0.01, },
			};
			
			//------------------------------------------------------------------
			function resizeCanvas() {
				canvasSize = window.innerHeight-6;
				if (window.innerWidth < canvasSize) canvasSize = window.innerWidth-6;
				halfCanvas = Math.round(canvasSize/2);
				canvasSizeReciprocal = 1/canvasSize;
				document.getElementById('mainContainer').style.width = (200+canvasSize)+'px';
				document.getElementById('canvasDiv').style.width = canvasSize+'px';
				if (ctx!==null) {
					ctx.canvas.width = canvasSize;
					ctx.canvas.height = canvasSize;
				}
				redraw();
			}

			//------------------------------------------------------------------
			var previousWindowHeight = 0;
			var previousWindowWidth = 0;
			function resizeHandler() {
				if (
					Math.abs(previousWindowHeight-window.innerHeight) > 3 ||
					Math.abs(previousWindowWidth-window.innerWidth) > 3
				) {
					previousWindowHeight = window.innerHeight;
					previousWindowWidth = window.innerWidth;
					
					resizeCanvas();				

					Celestial.resize({width:canvasSize});
					document.getElementById('celestialDiv').style.width = canvasSize+'px';
				}
			}//resizeHandler
			
			
			function load() {
				if (null !== document.getElementById('canvasMap'))
					ctx = document.getElementById('canvasMap').getContext('2d');
				
				document.getElementById('animateCheckbox').addEventListener('change', function(event) {
					if (doAnimateTime) {
						doAnimateTime = false;
						if (animateTimeout!==null) {
							clearTimeout(animateTimeout);
							animateTimeout = null;
						}
					} else {
						doAnimateTime = true;
						if (animateTimeout!==null) clearTimeout(animateTimeout);
						animateTimeout = setTimeout('redraw(true);',animateTimePeriod);
					}
				}); 
				
				animateTimeInterval = document.getElementById('animationSpeed').value;
				
				if (null!==document.getElementById('daylightCheckbox'))
					document.getElementById('daylightCheckbox').checked = showDaylight;
				
				document.getElementById('celestialDiv').style.display = (showStars)?'block':'none';
				
				if (null!==document.getElementById('starsCheckbox')) {
					document.getElementById('starsCheckbox').checked = showStars;
					document.getElementById('starsCheckbox').addEventListener('change', function(event) {
						if (showStars) {
							showStars = false;
							document.getElementById('celestialDiv').style.display = 'none';
						} else {
							showStars = true;
							//celestialDiv will be set to display=block in redraw() after datetime setting
						}
						redraw();
					});
				} 
				
				document.getElementById('latLongInput').addEventListener('keyup', function(event) {
					event.preventDefault();
					if (event.keyCode === 13) {
						//console.log('calling redraw after latLongInput');
						setTimeout('redraw();',10);
					}
				});				
				document.getElementById('dateTimeInput').addEventListener('keyup', function(event) {
					event.preventDefault();
					if (event.keyCode === 13) {
						//console.log('calling redraw after dateTimeInput');
						setTimeout('redraw();',10);
					}
				});	
				document.getElementById('showObserver').checked = showObserver;
				
				if (document.getElementById('canvasMap')!==null) {
				
					//TODO: when celestialDiv is displayed it prevents canvasMap from receiving clicks

					document.getElementById('canvasMap').addEventListener('click', function(event) { //mousedown
						var userPos = xyToGps(event.clientX, event.clientY);
						if (userPos !== false) {
							userLat = userPos.lat;
							userLng = userPos.lng;
							document.getElementById('latLongInput').value = (Math.round(userLat*100)/100) + ', ' + (Math.round(userLng*100)/100);
							setTimeout('redraw();',10);
						}
					}, false);
					document.getElementById('canvasMap').addEventListener('mousemove', function(event) {
						var mousePos = xyToGps(event.clientX, event.clientY);
						if (mousePos !== false && routeStartLat !== null && routeStartLng !== null) {
							redraw();
							//calculate flatearth-straight-looking path distance
							var stepX = (event.clientX - routeStartX);
							var stepY = (event.clientY - routeStartY);
							var stepCount = (Math.abs(stepX) + Math.abs(stepY));
							stepX = stepX / stepCount;
							stepY = stepY / stepCount;
							var oldPosX = routeStartX;
							var oldPosY = routeStartY;
							var oldCoord = xyToGps(oldPosX,oldPosY);
							var feDist = 0;
							
							for (var i=0; i<stepCount; i++) {
								
								var newPosX = oldPosX + stepX;
								var newPosY = oldPosY + stepY;
								var newCoord = xyToGps(newPosX,newPosY);
								drawDot(newCoord.lat, newCoord.lng, 2, '#d0c');
								feDist+= 6371*getAngularDistance(oldCoord.lat, oldCoord.lng, newCoord.lat, newCoord.lng);
								oldPosX = newPosX;
								oldPosY = newPosY;
								oldCoord = newCoord;
							}
							
							document.getElementById('feDistance').innerText = Math.round(feDist)+' km';
						
							//calculate globe great circle route
							routeEndLat = mousePos.lat;
							routeEndLng = mousePos.lng;
							
							var radAd = getAngularDistance(routeStartLat, routeStartLng, routeEndLat, routeEndLng);
							
							document.getElementById('gcDistance').innerText = Math.round(radAd*6371)+' km';
						
							drawDot(routeStartLat,routeStartLng, 2, '#0b0');
							
							var fracStep = canvasSizeReciprocal/radAd;
							
							for (var frac = fracStep; frac < 0.999999; frac += fracStep) {
								var fracPoint = getFracPoint(frac);
								drawDot(fracPoint.lat, fracPoint.lng, 2, '#0b0');
							}
							drawDot(routeEndLat, routeEndLng, 2, '#0b0');
						}
					}, false);
					document.getElementById('canvasMap').addEventListener('contextmenu', function(event) {
						var clickPos = xyToGps(event.clientX, event.clientY);
						if (clickPos !== false) {
							
							if (routeStartLat !== null && routeStartLng !== null) {
								/* * /
								routeEndLat = clickPos.lat;
								routeEndLng = clickPos.lng;
								
								var radAd = getAngularDistance(routeStartLat, routeStartLng, routeEndLat, routeEndLng);
								
								redraw();
							
								drawDot(routeStartLat,routeStartLng, 2, '#0b0');
								
								var fracStep = canvasSizeReciprocal/radAd;
								
								for (var frac = fracStep; frac < 0.999999; frac += fracStep) {
									var fracPoint = getFracPoint(frac);
									drawDot(fracPoint.lat, fracPoint.lng, 2, '#0b0');
								}
								drawDot(routeEndLat, routeEndLng, 2, '#0b0');
								/* */

								routeStartLat = null;
								routeStartLng = null;
							} else {
								routeStartX = event.clientX;
								routeStartY = event.clientY;
								routeStartLat = clickPos.lat;
								routeStartLng = clickPos.lng;
								drawDot(clickPos.lat, clickPos.lng, 2, '#0b0');
							}
						
						}
						event.preventDefault(); //stop context menu
					}, false);
					
				}

				resizeCanvas();
				
				navigator.geolocation.getCurrentPosition(function(position) {
					if (position.coords.latitude != 'NaN' && position.coords.longitude != 'NaN') 
						document.getElementById('latLongInput').value = (Math.round(position.coords.latitude*100)/100) + ' ' + (Math.round(position.coords.longitude*100)/100);
					//console.log('calling redraw after geo success');
					setTimeout('redraw();',10);
				},function(){ //geolocation unavailable
					userLat = previousLat; userLng = previousLng;
					//console.log('calling redraw after geo fail');
					setTimeout('redraw();',10); 
				});
				//--------------------------------------------------------------
				
				Celestial.display(celestialConfig);
				//Celestial.location([90, 0]);
				Celestial.resize({width:canvasSize});
				document.getElementById('celestialDiv').style.width = canvasSize+'px';
				for (var i=180;i<6000;i=i*2) setTimeout(function(){ Celestial.date(d); },i); //sometimes the objects don't get rendered if called too soon
				redraw();
			} //load()
		</script>
	</head>
	<body onload="load();" onresize="setTimeout('resizeHandler();',10);">
		<img id="mapimg" src="gleasonmap.jpg" style="display:none;" />
		<div id="mainContainer" style="padding:0px; margin:0px;">
			<div id="canvasDiv" style="float:left; padding:0px; margin:0px; display:block;"><canvas id="canvasMap"></canvas></div>
			<div id="celestialDiv" style="position:absolute; padding:0px; margin:0px; display:block;"></div>
			<div id="controlsDiv" style="float:right; padding:0px; margin:0px; width:200px;">
				<input type="checkbox" id="showObserver" checked="checked" onchange="showObserver = !showObserver; redraw();" />
				<label for="showObserver">Observer location:</label><br />
				<input type="text" id="latLongInput" value="0.00, 0.00" style="width:105px" /><button onclick="setTimeout('redraw();',10);">GO</button><br />
				<input type="checkbox" id="equatorCheckpoints" onchange="showEquatorCheckpoints = !showEquatorCheckpoints; redraw();" />
				<label for="equatorCheckpoints"> Equator Checkpoints</label><br />
				<input type="checkbox" id="northCheckpoints" onchange="showNorthCheckpoints = !showNorthCheckpoints; redraw();" />
				<label for="northCheckpoints"> North Checkpoints</label><br />
				<input type="checkbox" id="southCheckpoints" onchange="showSouthCheckpoints = !showSouthCheckpoints; redraw();" />
				<label for="southCheckpoints"> South Checkpoints</label><br />
				<input type="checkbox" id="flatDirection" onchange="showFlatDirection = !showFlatDirection; redraw();" />
				<label for="flatDirection"> flatearth direction to Sun</label><br />
				<br />
				Greenwich London time (UTC)<br />
				<input type="text" id="dateTimeInput" value="" style="width:110px" /><button onclick="setTimeout('redraw();',10);">set</button><br />
				<a href="#" onclick="return setMonth(1);">Jan</a>
				<a href="#" onclick="return setMonth(2);">Feb</a>
				<a href="#" onclick="return setMonth(3);">Mar</a>
				<a href="#" onclick="return setMonth(4);">Apr</a>
				<a href="#" onclick="return setMonth(5);">May</a>
				<a href="#" onclick="return setMonth(6);">Jun</a><br />
				<a href="#" onclick="return setMonth(7);">Jul</a>
				<a href="#" onclick="return setMonth(8);">Aug</a>
				<a href="#" onclick="return setMonth(9);">Sep</a>
				<a href="#" onclick="return setMonth(10);">Oct</a>
				<a href="#" onclick="return setMonth(11);">Nov</a>
				<a href="#" onclick="return setMonth(12);">Dec</a><br />
				<a href="#" onclick="return setMarchEquinox();">March equinox</a><br />
				<a href="#" onclick="return setJuneSolstice();">June solstice</a><br />
				<a href="#" onclick="return setSeptemberEquinox();">September equinox</a><br />
				<a href="#" onclick="return setDecemberSolstice();">December solstice</a><br />
				<input type="checkbox" id="animateCheckbox" /><label for="animateCheckbox"> Animate / speed:</label><br />
				<input type="range" id="animationSpeed" min="1" max="30" value="5"
					onchange="animateTimeInterval = this.value;" /><br />
				<span id="gcDistance" style="font-size:12px; color:#080; padding-left:5px;">right-click to measure distance</span>
				 / <span id="feDistance" style="font-size:12px; color:#b08;"></span>
				<br />
				<!-- stars don't work properly yet -->
				<!--input type="checkbox" id="starsCheckbox" /><label for="starsCheckbox"> Stars</label> / 
				<input type="checkbox" id="daylightCheckbox" onchange="showDaylight = !showDaylight; redraw();" />
				<label for="daylightCheckbox"> daylight</label>
				
				<br /><br /-->
				Sun pos:<br />
				<input type="text" id="latLongOutput" value="" readonly="readonly" style="width:105px" />
				<a id="sunPosCheckLink" href="https://www.timeanddate.com/worldclock/sunearth.html" target="_blank">(check<img src="external.svg" width="10" height="10" />)</a><br /><br />
				Zenith, azimuth:<br />
				<input type="text" id="zenAzOutput" value="0.00, 0.00" readonly="readonly" style="width:105px" />
				<a id="azimuthCheckLink" href="https://suncalc.org/" target="_blank">(check<img src="external.svg" width="10" height="10" />)</a><br /><br />
				<b id="dayCaption" style="color:#c00;">Red arrow = which direction is the Sun visible on the sky</b>
				<b id="nightCaption" style="display:none;">The Sun is not visible from observer location</b><br /><br />
				<a href="https://www.metabunk.org/direction-to-sun-vs-sun-position-above-the-ae-map-visualization.t10401/">metabunk discussion thread</a><br /><br />
				<div id="debug"></div>
			</div>
		</div>
	</body>
</html>