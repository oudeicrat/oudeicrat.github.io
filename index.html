<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv=Content-Type content="text/html; charset=utf-8">
		<title>Flat Earth Map and Sun Position</title>
		<style type="text/css">
			body { font-family:Arial; font-size:12px; margin:0px; padding:0px; }
			input { font-family:Arial; font-size:12px; }
			button { font-family:Arial; font-size:12px; }
		</style>
		<script type="text/javascript">
			//https://astronomy.stackexchange.com/questions/20560/how-to-calculate-the-position-of-the-sun-in-long-lat
			//Latitude of the Geographical Position (GP) is called Declination, and it is numerically equal 
			//to what one might call "Latitude". It is measured in degrees North or South the equator.
			//Longitude of the GP is called Greenwich Hour Angle (GHA)
			
			//http://answers.google.com/answers/threadview/id/782886.html
			//https://gist.github.com/jgomezdans/733741/
			
			var animateTime = false;
			var animateTimeout = null;
			var animateTimeInterval = 2; //add 2 minutes to reference UTC datetime
			var animateTimePeriod = 50; //50ms framerate
			
			var showEquatorCheckpoints = false;
			var showSouthCheckpoints = false;
			var showNorthCheckpoints = false;
			
			var canvasSize;
			var canvasSizeReciprocal;
			var m180divPI = 180/Math.PI;
			var rec180 = 1/180;
			
			var userLat = 0.00;
			var userLng = 0.00;
			var previousLat = 0.00;
			var previousLng = 0.00;
			var localGmtOffset = 0;
			var minutesOffset = 0;
			var declination = 0;
			var goingToRequest = false;
			var requestWaitTimeout = null;
			var year = new Date().getFullYear(); 


			function drawMap() {
				var ctx = document.getElementById('canvasMap').getContext('2d');
				var imageObj = document.getElementById('mapimg');
				
				ctx.globalAlpha = 0.5;
				ctx.drawImage(imageObj, 0, 0,canvasSize,canvasSize);
				ctx.globalAlpha = 1;
			}
			
			function gpsToMapXY(lat,lng) {
				var y = Math.round(canvasSize/2+(90-lat)/360*canvasSize*Math.cos(-lng/180*Math.PI));
				var x = Math.round(canvasSize/2+(lat-90)/360*canvasSize*Math.sin(-lng/180*Math.PI));
				return {x,y};
			}
			function xyToGps(x,y) {
				var rx = 2.0*x * canvasSizeReciprocal - 1.0;
				var ry = 2.0*y * canvasSizeReciprocal - 1.0;
				var r = Math.sqrt(rx*rx + ry*ry);
				if (r > 0.99) return false;

				var lat = 90-180*r;
				var lng = 0;
				if (ry > 0.0) {
					lng = Math.atan(rx/ry) * m180divPI;
				} else if (ry < 0.0) {
					if (rx>=0.0) lng = 180 - Math.atan(rx/(-ry)) * m180divPI;
					else lng = -180 - Math.atan(rx/(-ry)) * m180divPI;
				} else {
					if (rx>=0.0) lng = 90;
					else lng = -90;
				}
				return {'lat':lat,'lng':lng};
			}
			function drawPointGps(lat,lng,color,radius) {
				var ctx = document.getElementById('canvasMap').getContext('2d');
				ctx.fillStyle = color;
				ctx.beginPath();
				coord = gpsToMapXY(lat,lng);
				ctx.arc(coord.x, coord.y, radius, 0, 2*Math.PI, true);
				ctx.fill();			
			}
			function drawCompassGps(lat,lng,color,radius,thickness) {
				var ctx = document.getElementById('canvasMap').getContext('2d');
				coord = gpsToMapXY(lat,lng);
				ctx.beginPath();
				ctx.lineWidth = 1;
				ctx.strokeStyle = '#ccc';
				
				ctx.moveTo(coord.x, coord.y);
				ctx.lineTo(Math.round(canvasSize/2),Math.round(canvasSize/2));
				ctx.stroke();

				ctx.beginPath();
				ctx.lineWidth = thickness;
				ctx.strokeStyle = color;
				
				ctx.moveTo(coord.x - Math.sin(rad(lng))*radius, coord.y - Math.cos(rad(lng))*radius);
				ctx.lineTo(coord.x + Math.sin(rad(lng))*radius, coord.y + Math.cos(rad(lng))*radius);
				ctx.stroke();
				
				ctx.moveTo(coord.x - Math.cos(rad(lng))*radius, coord.y + Math.sin(rad(lng))*radius);
				ctx.lineTo(coord.x + Math.cos(rad(lng))*radius, coord.y - Math.sin(rad(lng))*radius);
				ctx.stroke();
				
				ctx.beginPath();
				ctx.lineWidth = 1;
				ctx.moveTo(coord.x - Math.cos(rad(lng))*3, coord.y + Math.sin(rad(lng))*3);
				ctx.lineTo(coord.x - Math.sin(rad(lng))*radius, coord.y - Math.cos(rad(lng))*radius);
				ctx.lineTo(coord.x + Math.cos(rad(lng))*3, coord.y - Math.sin(rad(lng))*3);
				ctx.stroke();

				ctx.font = '14px Arial';
				ctx.fillStyle = color;
				ctx.fillText('N', Math.round(coord.x - Math.sin(rad(lng))*radius*2 - 4), Math.round(coord.y - Math.cos(rad(lng))*radius*2 + 6) );
				
			}
			function drawArrow(lat,lng,az,lineWidth,arrowSize,color,elongationPattern) {
				var ctx = document.getElementById('canvasMap').getContext('2d');
				coord = gpsToMapXY(lat,lng);
				ctx.lineWidth = lineWidth;
				ctx.strokeStyle = color; //'#f32';
				ctx.beginPath();
				
				var arrowDirection = az - lng; //because AZ is relative to observer
				
				ctx.moveTo(coord.x, coord.y);
				var arrowX = coord.x + Math.sin(rad(arrowDirection)) * arrowSize;
				var arrowY = coord.y - Math.cos(rad(arrowDirection)) * arrowSize;
				ctx.lineTo(arrowX, arrowY);
				ctx.stroke();
				
				var arrowAngle = 12;
				var arrowLength = Math.round(2*arrowSize / 3); 
				
				ctx.moveTo(arrowX, arrowY);
				ctx.lineTo(coord.x + Math.sin(rad(arrowDirection+arrowAngle)) * arrowLength, coord.y - Math.cos(rad(arrowDirection+arrowAngle)) * arrowLength);
				ctx.stroke();
				
				ctx.moveTo(arrowX, arrowY);
				ctx.lineTo(coord.x + Math.sin(rad(arrowDirection-arrowAngle)) * arrowLength, coord.y - Math.cos(rad(arrowDirection-arrowAngle)) * arrowLength);
				ctx.stroke();

				if (elongationPattern!==false && elongationPattern!==null) {
					ctx.setLineDash(elongationPattern);
					ctx.lineWidth = 1;
					ctx.moveTo(coord.x, coord.y);
					arrowSize = canvasSize; //TODO: limit to the edge of canvas
					ctx.lineTo(coord.x + Math.sin(rad(arrowDirection)) * arrowSize, coord.y - Math.cos(rad(arrowDirection)) * arrowSize);
					ctx.stroke();
					ctx.setLineDash([]);
				}
			}
			
			
			function rad(deg) { return deg * Math.PI * rec180; } 
			
			function isSunVisible(observer,htcOffset,sinDecl,cosDecl) {
				//htcOffset = (h-12)*15 + TC
				//sinDecl = Math.sin(rad(Decl));
				//cosDecl = Math.cos(rad(Decl));
				var SHArto = htcOffset + observer.lng;  
				if (SHArto > 180) {
					SHArto = SHArto - 360;
				} else if (SHArto < -180) {
					SHArto = SHArto + 360;
				}
				
				var cosSZA = Math.sin(rad(observer.lat)) * sinDecl + Math.cos(rad(observer.lat)) * cosDecl * Math.cos(rad(SHArto));
				//cosSZA < 0 = sun is below horizon
				//cosSZA > 0 = sun is visible above horizon
				return cosSZA;
			}
			
			function getSunPos(d,observer) {
				//https://gist.github.com/jgomezdans/733741/
				
				year = d.getUTCFullYear();
				var startDate = new Date(Date.UTC(year,0,1,0,0,0));
				var doy = 1 + Math.floor((d - startDate) / (1000 * 60 * 60 * 24));
				//console.log('doy = ',doy);
				var h = d.getUTCHours() + d.getUTCMinutes()/60; //absolute value (not relative to observer)
				//console.log('h = ',h);
				//gdeg = (360/365.25)*(doy+ h/24)
				//g = radians(gdeg)
				var g = (2/365.25)*(doy + h/24)*Math.PI;
				//console.log('g(rad) = ',g);
				//console.log('g(deg) = ',g*180/Math.PI);
				//declination = sun Geographical Position latitude (absolute)
				var Decl = 0.396372-22.91327*Math.cos(g)+4.02543*Math.sin(g)-0.387205*Math.cos(2*g) 
					+ 0.051967*Math.sin(2*g)-0.154527*Math.cos(3*g) + 0.084798*Math.sin(3*g);
				//console.log('Decl = ',Decl);
				//solar angle time correction
				var TC = 0.004297+0.107029*Math.cos(g)-1.837877*Math.sin(g) - 0.837378*Math.cos(2*g) - 2.340475*Math.sin(2*g);
				//console.log('TC = ',TC);
				//Solar Hour Angle relative to observer SHArto = (hour-12)*15 + Longitude + TC
				var htcOffset = (h-12)*15 + TC;
				var SHArto = htcOffset + observer.lng;  
				if (SHArto > 180) {
					SHArto = SHArto - 360;
				} else if (SHArto < -180) {
					SHArto = SHArto + 360;
				}
				//console.log('userLng(deg) = ',userLng);
				//console.log('SHA relative to observer (deg) = ',SHArto);
				//absolute SHA = absolute sun Geographical Position longitude
				var SHAa = (12-h)*15 - TC;  
				if (SHAa > 180) {
					SHAa = SHAa - 360;
				} else if (SHAa < -180) {
					SHAa = SHAa + 360;
				}
				//console.log('absolute SHA (deg) = ',SHAa);
				
				//zenith (relative to observer)
				//cos(SZA) = sin(Latitude)*sin(Decl)+cos(Latitude)*cos(Decl)*cos(SHA)
				var sinDecl = Math.sin(rad(Decl));
				var cosDecl = Math.cos(rad(Decl));
				var cosSZA = Math.sin(rad(observer.lat)) * sinDecl + Math.cos(rad(observer.lat)) * cosDecl * Math.cos(rad(SHArto));
				//cosSZA < 0 = sun is below horizon
 				if (cosSZA > 1.00) cosSZA = 1.00;
 				if (cosSZA < -1.00) cosSZA = -1.00;
 				//console.log('cosSZA = ',cosSZA);
 				var SZArad = Math.acos(cosSZA);
 				//console.log('SZArad = ',SZArad);
 				var SZA = SZArad * m180divPI; //zenith>90 = sun is below horizon
 				//console.log('SZA = ',SZA);
   
				//azimuth (relative to observer)
				//cos(AZ) = (sin(Decl)-sin(Latitude)*cos(SZA))/(cos(Latitude)*sin(SZA))
				var cosAZ = (Math.sin(rad(Decl)) - Math.sin(rad(observer.lat)) * Math.cos(SZArad)) / (Math.cos(rad(observer.lat)) * Math.sin(SZArad));
 				if (cosAZ > 1.00) cosAZ = 1.00;
 				if (cosAZ < -1.00) cosAZ = -1.00;
 				//console.log('cosAZ = ',cosAZ);
				var AZ = Math.acos(cosAZ) * m180divPI;
				if (SHArto>0) AZ = 360 - AZ; //https://en.wikipedia.org/wiki/Solar_azimuth_angle#Formulas "...between 180 and 360 degrees when the hour angle is positive (afternoon)"
				//console.log('AZ = ',AZ);
				
				return {'lat':Decl, 'lng':SHAa, 'az':AZ, 'zen':SZA, 'htcOffset':htcOffset, 'sinDecl':sinDecl, 'cosDecl':cosDecl }; //lat,lng = absolute; az,zen = relative to observer  
			}
			
			//compare to: https://www.timeanddate.com/worldclock/sunearth.html
			
			
			function outputUTCDateTime(d) {
				year = d.getUTCFullYear();
				document.getElementById('dateTimeInput').value = year + '-' + String('0'+(d.getUTCMonth()+1)).slice(-2)
					+ '-' + String('0'+d.getUTCDate()).slice(-2) + ' ' + String('0'+d.getUTCHours()).slice(-2) + ':' 
					+ String('0'+d.getUTCMinutes()).slice(-2); // + ':' + String('0'+d.getUTCSeconds()).slice(-2);
			}

			function updateAzimuthCheckLink(d, localGmtOffset) {
				var localDate = new Date(d.getTime() + localGmtOffset);
				
				document.getElementById('azimuthCheckLink').href = 'https://www.suncalc.org/#/'
					+ (Math.round(userLat*100)/100) + ',' + (Math.round(userLng*100)/100) + ',2/'
					+ localDate.getUTCFullYear()+'.'+String('0'+(localDate.getUTCMonth()+1)).slice(-2)+'.'+String('0'+localDate.getUTCDate()).slice(-2)
					+ '/' + String('0'+localDate.getUTCHours()).slice(-2) + ':' + String('0'+localDate.getUTCMinutes()).slice(-2) + '/1/0';
			}
			
			
			function showAltSunPos(d) {
				var altPos = [
					{'pos':{'lat':0.0,'lng':-150},'cat':0},
					{'pos':{'lat':0.0,'lng':-120},'cat':0},
					{'pos':{'lat':0.0,'lng':-90},'cat':0},
					{'pos':{'lat':0.0,'lng':-60.0},'cat':0},
					{'pos':{'lat':0.0,'lng':-30.0},'cat':0},
					{'pos':{'lat':0.0,'lng':0.0},'cat':0},
					{'pos':{'lat':0.0,'lng':30.0},'cat':0},
					{'pos':{'lat':0.0,'lng':60.0},'cat':0},
					{'pos':{'lat':0.0,'lng':90},'cat':0},
					{'pos':{'lat':0.0,'lng':120.0},'cat':0},
					{'pos':{'lat':0.0,'lng':150.0},'cat':0},
					{'pos':{'lat':0.0,'lng':180},'cat':0},

					{'pos':{'lat':-60.0,'lng':-150},'cat':-60},
					{'pos':{'lat':-60.0,'lng':-120},'cat':-60},
					{'pos':{'lat':-60.0,'lng':-90},'cat':-60},
					{'pos':{'lat':-60.0,'lng':-60.0},'cat':-60},
					{'pos':{'lat':-60.0,'lng':-30.0},'cat':-60},
					{'pos':{'lat':-60.0,'lng':0.0},'cat':-60},
					{'pos':{'lat':-60.0,'lng':30.0},'cat':-60},
					{'pos':{'lat':-60.0,'lng':60.0},'cat':-60},
					{'pos':{'lat':-60.0,'lng':90},'cat':-60},
					{'pos':{'lat':-60.0,'lng':120.0},'cat':-60},
					{'pos':{'lat':-60.0,'lng':150.0},'cat':-60},
					{'pos':{'lat':-60.0,'lng':180},'cat':-60},
					
					{'pos':{'lat':60.0,'lng':-150},'cat':60},
					{'pos':{'lat':60.0,'lng':-120},'cat':60},
					{'pos':{'lat':60.0,'lng':-90},'cat':60},
					{'pos':{'lat':60.0,'lng':-60.0},'cat':60},
					{'pos':{'lat':60.0,'lng':-30.0},'cat':60},
					{'pos':{'lat':60.0,'lng':0.0},'cat':60},
					{'pos':{'lat':60.0,'lng':30.0},'cat':60},
					{'pos':{'lat':60.0,'lng':60.0},'cat':60},
					{'pos':{'lat':60.0,'lng':90},'cat':60},
					{'pos':{'lat':60.0,'lng':120.0},'cat':60},
					{'pos':{'lat':60.0,'lng':150.0},'cat':60},
					{'pos':{'lat':60.0,'lng':180},'cat':60},
					
					//{'pos':{'lat':,'lng':},'cat':''},
					//{'pos':{'lat':,'lng':},'cat':''},
					//{'pos':{'lat':,'lng':},'cat':''},
					//{'pos':{'lat':,'lng':},'cat':''},
					//{'pos':{'lat':,'lng':},'cat':''},
					//{'pos':{'lat':,'lng':},'cat':''},
					//{'pos':{'lat':-31.95,'lng':115.86},'cat':'Perth'},
					//{'pos':{'lat':40.72,'lng':-74.0},'cat':'New York'},
					//{'pos':{'lat':51.51,'lng':-0.13},'cat':'London'}
				];
				for (var i in altPos) {
					if (
						(altPos[i].cat == 0 && showEquatorCheckpoints) ||
						(altPos[i].cat == -60 && showSouthCheckpoints) ||
						(altPos[i].cat == 60 && showNorthCheckpoints)
					) {
						var altSunPos = getSunPos(d,altPos[i].pos);
						if (altSunPos.zen > 100) { //sun below horizon (>90 + padding)
							//drawCompassGps(altPos[i].pos.lat, altPos[i].pos.lng, '#000', 8, 1);
						} else { //sun above horizon
							drawArrow(altPos[i].pos.lat, altPos[i].pos.lng, altSunPos.az, 1, 20, '#000', [2,10]);
							//drawCompassGps(altPos[i].pos.lat, altPos[i].pos.lng, '#000', 8, 1);
						}
					}
					
				}

			}
			
			function drawNight(htcOffset, sinDecl, cosDecl) {
				//isSunVisible(testPosition, htcOffset, sinDecl, cosDecl);
				var ctx = document.getElementById('canvasMap').getContext('2d');
				
				canvasRadius = canvasSize/2;
				canvasRadiusSquared = canvasSize*canvasSize/4;
				var tileSize = 6;
				var halfTileSize = 3;
				var visibility = -1;
				var pos = false;
				var drawNightSegment = false;
				
				for (var x=0; x<canvasSize; x+=tileSize) {
					for (var y=0; y<canvasSize; y+=tileSize) {
						pos = xyToGps(x,y);
						if (pos !== false) {
							visibility = isSunVisible(pos, htcOffset, sinDecl, cosDecl);
							drawNightSegment = true;
							ctx.globalAlpha = 1;
							if (visibility > 0.1) {
								drawNightSegment = false;
								//if (visibility > 0.85) {
								//	ctx.globalAlpha = (visibility-0.84)*2;
								//	ctx.fillStyle = '#ff0';
								//	ctx.beginPath();
								//	ctx.rect(x-halfTileSize, y-halfTileSize, tileSize, tileSize);
								//	ctx.fill();
								//}
							} else if (visibility > -0.2) {
								ctx.globalAlpha = 1-(visibility+0.2)*3.33;
							}
							
							if (drawNightSegment) {
								ctx.fillStyle = '#000';
								ctx.beginPath();
								ctx.rect(x-halfTileSize, y-halfTileSize, tileSize, tileSize);
								ctx.fill();
							}
						}
					}
				}
				ctx.globalAlpha = 1;
			}

			
			
			function redraw() {
				if (animateTimeout!==null) clearTimeout(animateTimeout);
				//console.log('redraw called');
				previousWindowHeight = window.innerHeight;
				previousWindowWidth = window.innerWidth;
				
				canvasSize = window.innerHeight-6;
				canvasSizeReciprocal = 1/canvasSize;
				if (window.innerWidth < canvasSize) canvasSize = window.innerWidth-6;
				document.getElementById('mainContainer').style.width = (200+canvasSize)+'px';
				document.getElementById('canvasDiv').style.width = canvasSize+'px';
				var ctx = document.getElementById('canvasMap').getContext('2d');
				ctx.canvas.width = canvasSize;
				ctx.canvas.height = canvasSize;
				
				var parsedUserLocation = /^(-?[0-9]+(?:.[0-9]+)?)[\s,;]+(-?[0-9]+(?:.[0-9]+)?)$/.exec(document.getElementById('latLongInput').value);
				if (
					//typeof parsedUserLocation != 'null' &&
					typeof parsedUserLocation != 'undefined' &&
					parsedUserLocation != null &&
					//parsedUserLocation != false &&
					'1' in  parsedUserLocation &&
					'2' in  parsedUserLocation &&
					typeof parsedUserLocation[1] != 'undefined' &&  
					typeof parsedUserLocation[2] != 'undefined' &&
					'NaN' != parseFloat(parsedUserLocation[1]) &&
					'NaN' != parseFloat(parsedUserLocation[2])
				) {
					userLat = Math.round(parseFloat(parsedUserLocation[1])*100)/100;
					userLng = Math.round(parseFloat(parsedUserLocation[2])*100)/100;
					
					if (userLat != 'NaN' && userLng != 'NaN')
						document.getElementById('latLongInput').value = (Math.round(userLat*100)/100) + ', ' + (Math.round(userLng*100)/100);
				} else {
					alert('unknown GPS format, use -12.34, 56.78');
				}
				
				var d = null;
				var parsedDate = /^([0-9]{4})[-]([0-9]{1,2})[-]([0-9]{1,2})(?:[ ]([0-9]{1,2})[:]([0-9]{1,2})(?:[:]([0-9]{1,2}))?)?$/.exec(document.getElementById('dateTimeInput').value);
				if (
					typeof parsedDate != 'undefined' &&
					parsedDate != null &&
					'1' in parsedDate &&
					'2' in parsedDate &&
					'3' in parsedDate &&
					typeof parsedDate[1] != 'undefined' &&  
					typeof parsedDate[2] != 'undefined' &&
					typeof parsedDate[3] != 'undefined' &&
					'NaN' != parseInt(parsedDate[1]) &&
					'NaN' != parseInt(parsedDate[2]) &&
					'NaN' != parseInt(parsedDate[3])
				) {
					if (!('4' in parsedDate) || typeof parsedDate[4] == 'undefined' || 'NaN'==parseInt(parsedDate[4])) parsedDate[4] = 0; 
					if (!('5' in parsedDate) || typeof parsedDate[5] == 'undefined'  || 'NaN'==parseInt(parsedDate[5])) parsedDate[5] = 0; 
					if (!('6' in parsedDate) || typeof parsedDate[6] == 'undefined'  || 'NaN'==parseInt(parsedDate[6])) parsedDate[6] = 0; 
				
					d = new Date(Date.UTC(
						parseInt(parsedDate[1]),
						parseInt(parsedDate[2])-1,
						parseInt(parsedDate[3]),
						parseInt(parsedDate[4]),
						parseInt(parsedDate[5]),
						parseInt(parsedDate[6]),
					));
				}
				
				if (d === null || d == 'Invalid Date' || d == 'NaN') { //use current time if no valid value entered
				
					var d = new Date(); //browser datetime in the timezone of the browser
					//outputUTCDateTime(d);
					
					localGmtOffset = d.getTimezoneOffset()*60000;
				}
				
				outputUTCDateTime(d);

				var sunPos = getSunPos(d,{'lat':userLat,'lng':userLng});
				
				drawNight(sunPos.htcOffset, sunPos.sinDecl, sunPos.cosDecl);
				drawMap();
				
				if (sunPos.lat != 'NaN' && sunPos.lng != 'NaN')
					document.getElementById('latLongOutput').value = Math.round(sunPos.lat*100)/100 + ', ' + Math.round(sunPos.lng*100)/100;
				if (sunPos.zen != 'NaN' && sunPos.az != 'NaN')
					document.getElementById('zenAzOutput').value = Math.round(sunPos.zen*100)/100 + ', ' + Math.round(sunPos.az*100)/100;
				if (sunPos.zen > 100) { //sun below horizon (>90 + padding)
					drawPointGps(sunPos.lat, sunPos.lng, '#ff0', 10);
					drawCompassGps(userLat, userLng, '#000', 13, 2);
					document.getElementById('dayCaption').style.display = 'none';
					document.getElementById('nightCaption').style.display = 'inline';
				} else { //sun above horizon
					drawPointGps(sunPos.lat, sunPos.lng, '#ff0', 10);
					drawArrow(userLat, userLng, sunPos.az, 3, 50, '#f32', [8,4]);
					drawCompassGps(userLat, userLng, '#000', 13, 2);
					document.getElementById('dayCaption').style.display = 'inline';
					document.getElementById('nightCaption').style.display = 'none';
				}
				
				showAltSunPos(d);
				
				document.getElementById('sunPosCheckLink').href = 'https://www.timeanddate.com/worldclock/sunearth.html?month='
					+ (d.getUTCMonth()+1) + '&day=' + d.getUTCDate() + '&year=' + d.getUTCFullYear() + '&hour='
					+ d.getUTCHours() + '&min=' + d.getUTCMinutes() + '&ntxt=London';
					
				if (
					Math.round(10*previousLat)/10 != Math.round(10*userLat)/10 || 
					Math.round(10*previousLng)/10 != Math.round(10*userLng)/10
				) {
					document.getElementById('azimuthCheckLink').href = 'https://www.suncalc.org/';
					if (goingToRequest) {
						clearTimeout(requestWaitTimeout);
						goingToRequest = false;
						//console.log('clearing request timeout');
					}
					goingToRequest = true;
					//console.log('setting up request timeout');
					requestWaitTimeout = setTimeout(function(){
						goingToRequest = false;	
						var xhr = new XMLHttpRequest();
						xhr.onload = function() {
							if (this.readyState == 4 && this.status == 200) {
								var jsonData = JSON.parse(this.responseText);
								if ('status' in jsonData && jsonData.status=='OK' && 'gmtOffset' in jsonData) {
									localGmtOffset = jsonData.gmtOffset*1000; //eg. GMT+1 -> jsonData.gmtOffset = 3600
									
									updateAzimuthCheckLink(d, localGmtOffset);

								} else {
									//console.log('timezonedb.com request unsuccessful');
									//sometimes timezone is not found (for example in the ocean)
								}
							} else { alert('requesting timezonedb.com failed'); }
							previousLat = userLat; previousLng = userLng;
						};
						var timeZoneDbUrl = 'https://api.timezonedb.com/v2.1/get-time-zone?key=H57PYG9KKM6P&format=json&by=position&lat='
							+ (Math.round(userLat*100)/100) + '&lng=' + (Math.round(userLng*100)/100);
						
						xhr.open('get', timeZoneDbUrl);
						//console.log('requesting timezonedb.com');
						xhr.send();
						
						
					},1200);
				} else {
					updateAzimuthCheckLink(d, localGmtOffset)
				}
				
				if (animateTime) {
					d = new Date(d.getTime() + animateTimeInterval*60000); //add animateTimeInterval minutes
					outputUTCDateTime(d);
					if (animateTimeout!==null) clearTimeout(animateTimeout);
					animateTimeout = setTimeout('redraw();',animateTimePeriod);
				}
			} //redraw
			
			function setMarchEquinox() {
				document.getElementById('dateTimeInput').value = year+'-03-20 03:00';
				setTimeout('redraw();',10);
				return false;
			}
			function setJuneSolstice() {
				document.getElementById('dateTimeInput').value = year+'-06-20 20:00';
				setTimeout('redraw();',10);
				return false;
			}
			function setSeptemberEquinox() {
				document.getElementById('dateTimeInput').value = year+'-09-22 05:00';
				setTimeout('redraw();',10);
				return false;
			}
			function setDecemberSolstice() {
				document.getElementById('dateTimeInput').value = year+'-12-21 05:00';
				setTimeout('redraw();',10);
				return false;
			}
			function setMonth(monthNumber) {
				if (monthNumber < 10) monthNumber = '0'+monthNumber;
				document.getElementById('dateTimeInput').value = document.getElementById('dateTimeInput').value.replace(/^([0-9]+[-])[0-9]+([-].+)$/,'$1'+monthNumber+'$2');
				setTimeout('redraw();',10);
				return false;
			}
			
			function load() {
				canvasSize = window.innerHeight-6;
				
				navigator.geolocation.getCurrentPosition(function(position) {
					if (position.coords.latitude != 'NaN' && position.coords.longitude != 'NaN') 
						document.getElementById('latLongInput').value = (Math.round(position.coords.latitude*100)/100) + ' ' + (Math.round(position.coords.longitude*100)/100);
					//console.log('calling redraw after geo success');
					setTimeout('redraw();',10);
				},function(){ //geolocation unavailable
					userLat = previousLat; userLng = previousLng;
					//console.log('calling redraw after geo fail');
					setTimeout('redraw();',10); 
				});
				
				document.getElementById('animateCheckbox').addEventListener('change', function(event) {
					if (animateTime) {
						animateTime = false;
						if (animateTimeout!==null) {
							clearTimeout(animateTimeout);
							animateTimeout = null;
						}
					} else {
						animateTime = true;
						if (animateTimeout!==null) clearTimeout(animateTimeout);
						animateTimeout = setTimeout('redraw();',animateTimePeriod);
					}
				}); 
				
				document.getElementById('latLongInput').addEventListener('keyup', function(event) {
					event.preventDefault();
					if (event.keyCode === 13) {
						//console.log('calling redraw after latLongInput');
						setTimeout('redraw();',10);
					}
				});				
				document.getElementById('dateTimeInput').addEventListener('keyup', function(event) {
					event.preventDefault();
					if (event.keyCode === 13) {
						//console.log('calling redraw after dateTimeInput');
						setTimeout('redraw();',10);
					}
				});	
				
				document.getElementById('canvasMap').addEventListener('click', function(event) { //mousedown
					var userPos = xyToGps(event.clientX, event.clientY);
					if (userPos !== false) {
						userLat = userPos.lat;
						userLng = userPos.lng;
						document.getElementById('latLongInput').value = (Math.round(userLat*100)/100) + ', ' + (Math.round(userLng*100)/100);
						setTimeout('redraw();',10);
					}
					/*
					var x = 2*event.clientX / canvasSize - 1;
					var y = 2*event.clientY / canvasSize - 1;
					var r = Math.sqrt(x*x + y*y);
					if (r < 0.99) {
					
						userLat = 90-180*r;
						if (y > 0.0) {
							userLng = 180*Math.atan(x/y)/Math.PI;
						} else if (y < 0.0) {
							if (x>=0.0) userLng = 180-180*Math.atan(x/(-y))/Math.PI;
							else userLng = -180-180*Math.atan(x/(-y))/Math.PI;
						} else {
							if (x>=0.0) userLng = 90;
							else userLng = -90;
						}
						if (userLat != 'NaN' && userLng != 'NaN')
							document.getElementById('latLongInput').value = (Math.round(userLat*100)/100) + ', ' + (Math.round(userLng*100)/100);
						setTimeout('redraw();',10);
					}*/
				}, false);
			}
			var previousWindowHeight = 0;
			var previousWindowWidth = 0;
			function resizeHandler() {
				if (
					Math.abs(previousWindowHeight-window.innerHeight) > 3 ||
					Math.abs(previousWindowWidth-window.innerWidth) > 3
				) {
					//console.log('calling redraw after resize');
					redraw();
				}
			}
		</script>
	</head>
	<body onload="load();" onresize="setTimeout('resizeHandler();',10);">
		<img id="mapimg" src="gleasonmap.jpg" style="display:none;" />
		<div id="mainContainer" style="padding:0px; margin:0px;">
			<div id="canvasDiv" style="float:left; padding:0px; margin:0px;"><canvas id="canvasMap"></canvas></div>
			<div id="controlsDiv" style="float:right; padding:0px; margin:0px; width:200px;">
				Observer location:<br />
				<input type="text" id="latLongInput" value="0.00, 0.00" style="width:105px" /><button onclick="setTimeout('redraw();',10);">GO</button><br />
				<input type="checkbox" id="equatorCheckpoints" onchange="showEquatorCheckpoints = !showEquatorCheckpoints;
				if (!animateTime) redraw();" /><label for="equatorCheckpoints"> Equator Checkpoints</label><br />
				<input type="checkbox" id="northCheckpoints" onchange="showNorthCheckpoints = !showNorthCheckpoints;
				if (!animateTime) redraw();" /><label for="northCheckpoints"> North Checkpoints</label><br />
				<input type="checkbox" id="southCheckpoints" onchange="showSouthCheckpoints = !showSouthCheckpoints;
				if (!animateTime) redraw();" /><label for="southCheckpoints"> South Checkpoints</label><br />
				<br />
				Greenwich London time (UTC)<br />
				<input type="text" id="dateTimeInput" value="" style="width:110px" /><button onclick="setTimeout('redraw();',10);">set</button><br />
				<a href="#" onclick="return setMonth(1);">January</a><br />
				<a href="#" onclick="return setMonth(2);">February</a><br />
				<a href="#" onclick="return setMonth(3);">March</a><br />
				<a href="#" onclick="return setMarchEquinox();">March equinox</a><br />
				<a href="#" onclick="return setMonth(4);">April</a><br />
				<a href="#" onclick="return setMonth(5);">May</a><br />
				<a href="#" onclick="return setMonth(6);">June</a><br />
				<a href="#" onclick="return setJuneSolstice();">June solstice</a><br />
				<a href="#" onclick="return setMonth(7);">July</a><br />
				<a href="#" onclick="return setMonth(8);">August</a><br />
				<a href="#" onclick="return setMonth(9);">September</a><br />
				<a href="#" onclick="return setSeptemberEquinox();">September equinox</a><br />
				<a href="#" onclick="return setMonth(10);">October</a><br />
				<a href="#" onclick="return setMonth(11);">November</a><br />
				<a href="#" onclick="return setMonth(12);">December</a><br />
				<a href="#" onclick="return setDecemberSolstice();">December solstice</a><br />
				<input type="checkbox" id="animateCheckbox" /><label for="animateCheckbox"> Animate</label><br /><br />
				Sun pos:<br />
				<input type="text" id="latLongOutput" value="" readonly="readonly" style="width:105px" />
				<a id="sunPosCheckLink" href="https://www.timeanddate.com/worldclock/sunearth.html" target="_blank">(check<img src="external.svg" width="10" height="10" />)</a><br /><br />
				Zenith, azimuth:<br />
				<input type="text" id="zenAzOutput" value="0.00, 0.00" readonly="readonly" style="width:105px" />
				<a id="azimuthCheckLink" href="https://suncalc.org/" target="_blank">(check<img src="external.svg" width="10" height="10" />)</a><br /><br />
				<b id="dayCaption" style="color:#c00;">Red arrow = which direction is the Sun visible on the sky</b>
				<b id="nightCaption" style="display:none;">The Sun is not visible from observer location</b><br /><br />
				<a href="https://www.metabunk.org/direction-to-sun-vs-sun-position-above-the-ae-map-visualization.t10401/">metabunk discussion thread</a><br /><br />
				<div id="debug"></div>
			</div>
		</div>
	</body>
</html>