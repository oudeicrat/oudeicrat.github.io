<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<meta http-equiv=Content-Type content="text/html; charset=utf-8" />
		<title>Flat Earth Map and Sun Position</title>
		<script type="text/javascript" src="citiesgps.js"></script> <!-- var citiesGps = {{"`Ajlun JOR",32.3333,35.7528},... -->
		<script type="text/javascript" src="lib/d3.js"></script>
		<script type="text/javascript" src="lib/d3.geo.projection.js"></script>
		<script type="text/javascript" src="lib/d3.geo.zoom.js"></script>

		<script type="text/javascript" src="celestial.js"></script>
		<script type="text/javascript" src="celestial2nd.js"></script>
		<script type="text/javascript">
			//in var projections
			//change line
			//  "azimuthalEquidistant": {n:"Azimuthal Equidistant", arg:null, scale:320, ratio:1.0, clip:true},
			//to
			//  "azimuthalEquidistant": {n:"Azimuthal Equidistant", arg:null, scale:320, ratio:1.0, clip:false},
			
			//in Celestial.projection = function(projection) {
			//change line
			//  var coords = raw(-λ, φ);
			//to
			//  var coords = raw(λ, φ);
		</script>
		<link rel="stylesheet" href="celestial.css" />

		<style type="text/css">
			body { font-family:Arial; font-size:12px; margin:0px; padding:0px; }
			input { font-family:Arial; font-size:12px; }
			button { font-family:Arial; font-size:12px; }
			#locationSelector { border:solid 1px #000; padding:2px; padding-bottom:7px; cursor:default; }
			#locationSelector div { cursor:default; }
			#locationSelector.searchInProgress { cursor:wait; }
			#locationSelector.searchInProgress div { cursor:wait; }
			#locationSelector.searchInProgress input { cursor:wait; }
			#locationSelector div:hover { background-color:#fff; color:#333; }
			ul#footerLinks { list-style-position:inside; list-style:inside; margin-left:0px; padding-left:0px; }
		</style>
		<script type="text/javascript">
			var jsDate = null;

			//https://astronomy.stackexchange.com/questions/20560/how-to-calculate-the-position-of-the-sun-in-long-lat
			//Latitude of the Geographical Position (GP) is called Declination, and it is numerically equal
			//to what one might call "Latitude". It is measured in degrees North or South the equator.
			//Longitude of the GP is called Greenwich Hour Angle (GHA)

			//http://answers.google.com/answers/threadview/id/782886.html
			//https://gist.github.com/jgomezdans/733741/

			var ctx = null;
			var topCtx = null;
			var celestialViewTimezoneOffset = 0; //-360; //correction for d3 celestial sky orientation
			var celestialViewOrientation = 0; //90; //this value doesn't do anything //alternative correction for sky orientation
			var showObserver = true;
			var showSkyHorizon = false;
			var showStars = false;
			var showLocalView = true;
			var localViewDocked = false;
			var celestialInitialised = false;
			var localCelestialInitialised = false;
			var showDaylight = true;

			var doAnimateTime = false;
			var animateTimeout = null;
			var oldAnimationSpeedSlider = 0;
			var animateTimeInterval; //add x milliseconds to reference UTC datetime
			//var animateTimeInterval = 60*24*60*1000; //add 1 day to reference UTC datetime

			var animateTimePeriod = 30; //framerate in ms
			var animTimeFactor = 1;
			
			var showDockerDiv = true;

			var showEquatorCheckpoints = false;
			var showSouthCheckpoints = false;
			var showNorthCheckpoints = false;
			var showFlatDirection = false;
			var showDistanceGpsModal = false;

			var celestialConfig;
			var localCelestialConfig;
			var canvasSize;
			var halfCanvas;
			var canvasSizeReciprocal;
			var localCelestialDivId = 'localCelestialDiv';
			var localCelestialDivSize;
			var localViewUndockedOffset = 200;
			var localViewLeftOffset = localViewDocked ? 0 : localViewUndockedOffset;
			var m180divPI = 180/Math.PI;
			var rec180 = 1/180;

			var userLat = 0.00;
			var userLng = 0.00;
			var previousLat = 0.00;
			var previousLng = 0.00;
			var oldHorizonLat = null; //for drawing the sky horizon
			var oldHorizonLng = null;
			
			var observerGmtOffset = 0; //relative to selected observer position
			var minutesOffset = 0;
			var declination = 0;
			var goingToRequest = false;
			var requestWaitTimeout = null;
			var year = new Date().getFullYear();

			var tooltipStyle;
			var routeStartLat = null;
			var routeStartLng = null;
			var routeEndLat = null;
			var routeEndLng = null;
			
			var previewLat = null;
			var previewLng = null;

			var dateTimeSelectorHideTimeout = null;
			
			var locationSelectorHideTimeout = null;
			var locationSelectorSearchTimeout = null;
			var locationSelectorSearchAbort = false;
			var locationSearchLast = null;
			var locationSelectorElements = []; //[ 0: element id number, 1: city name, 2: lat, 3: lng ]
			function drawMap() {
				if (ctx===null) return false;
				var imageObj = document.getElementById('mapimg');

				ctx.globalAlpha = 0.5;
				ctx.beginPath();
				ctx.drawImage(imageObj, 0, 0,canvasSize,canvasSize);
				ctx.globalAlpha = 1;
			}

			function gpsToMapXY(lat,lng) {
				var y = Math.round(canvasSize/2+(90-lat)/360*canvasSize*Math.cos(-lng/180*Math.PI));
				var x = Math.round(canvasSize/2+(lat-90)/360*canvasSize*Math.sin(-lng/180*Math.PI));
				return {x,y};
			}
			function xyToGps(x,y) {
				var rx = 2.0*x * canvasSizeReciprocal - 1.0;
				var ry = 2.0*y * canvasSizeReciprocal - 1.0;
				var r = Math.sqrt(rx*rx + ry*ry);
				if (r > 0.999999) return false;

				var lat = 90-180*r;
				var lng = 0;
				if (ry > 0.0) {
					lng = Math.atan(rx/ry) * m180divPI;
				} else if (ry < 0.0) {
					if (rx>=0.0) lng = 180 - Math.atan(rx/(-ry)) * m180divPI;
					else lng = -180 - Math.atan(rx/(-ry)) * m180divPI;
				} else {
					if (rx>=0.0) lng = 90;
					else lng = -90;
				}
				return {'lat':lat,'lng':lng};
			}
			function drawDot(lat, lng, radius, color) {
				ctx.fillStyle = color;
				ctx.beginPath();
				coord = gpsToMapXY(lat,lng);
				ctx.lineWidth = 1;
				ctx.beginPath();
				ctx.arc(coord.x, coord.y, radius, 0, 2*Math.PI, true);
				ctx.strokeStyle = color;
				ctx.stroke();
				ctx.fill();
			}

			function drawSun(lat,lng) {
				if (ctx===null) return false;
				ctx.fillStyle = '#fd0';
				ctx.beginPath();
				coord = gpsToMapXY(lat,lng);
				ctx.lineWidth = 2;
				ctx.arc(coord.x, coord.y, 10, 0, 2*Math.PI, true); //3rd param = radius
				ctx.strokeStyle = '#fb0';
				ctx.stroke();
				if (!showStars) ctx.fill();
			}
			function drawCompassGps(lat,lng,color,radius,thickness,letter) {
				if (ctx===null) return false;
				if (typeof letter === 'undefined' || letter===null) letter = true;
				coord = gpsToMapXY(lat,lng);
				
				//line from location to north pole
				//ctx.lineWidth = 1;
				//ctx.strokeStyle = '#ccc';
				//ctx.beginPath();
				//ctx.moveTo(coord.x, coord.y);
				//ctx.lineTo(halfCanvas,halfCanvas);
				//ctx.stroke();

				ctx.lineWidth = thickness;
				ctx.strokeStyle = color;
				ctx.beginPath();
				ctx.moveTo(coord.x - Math.sin(rad(lng))*radius, coord.y - Math.cos(rad(lng))*radius);
				ctx.lineTo(coord.x + Math.sin(rad(lng))*radius, coord.y + Math.cos(rad(lng))*radius);
				ctx.stroke();

				ctx.beginPath();
				ctx.moveTo(coord.x - Math.cos(rad(lng))*radius, coord.y + Math.sin(rad(lng))*radius);
				ctx.lineTo(coord.x + Math.cos(rad(lng))*radius, coord.y - Math.sin(rad(lng))*radius);
				ctx.stroke();

				ctx.beginPath();
				ctx.lineWidth = 1;
				ctx.moveTo(coord.x - Math.cos(rad(lng))*3, coord.y + Math.sin(rad(lng))*3);
				ctx.lineTo(coord.x - Math.sin(rad(lng))*radius, coord.y - Math.cos(rad(lng))*radius);
				ctx.lineTo(coord.x + Math.cos(rad(lng))*3, coord.y - Math.sin(rad(lng))*3);
				ctx.stroke();

				if (letter) {
					ctx.font = '14px Arial';
					ctx.fillStyle = color;
					ctx.fillText('N', Math.round(coord.x - Math.sin(rad(lng))*radius*2 - 4), Math.round(coord.y - Math.cos(rad(lng))*radius*2 + 6) );
				}
			}
			function drawArrow(lat,lng,posDir,lineWidth,arrowSize,color,elongationPattern) {
				if (ctx===null) return false;
				if (typeof elongationPattern === 'undefined') elongationPattern = null;
				var arrowDirection = null;
				var arrowX = null;
				var arrowY = null;

				var coord = gpsToMapXY(lat,lng);

				if (typeof posDir === 'number') { //posDir = AZ
					arrowDirection = posDir - lng; //because AZ is relative to observer
					arrowX = coord.x + Math.sin(rad(arrowDirection)) * arrowSize;
					arrowY = coord.y - Math.cos(rad(arrowDirection)) * arrowSize;

				} else if ( //posDir = lat,lng
					typeof posDir === 'object' &&
					typeof posDir.lat === 'number' &&
					typeof posDir.lng === 'number'
				) {
					var arrowEndpoint = gpsToMapXY(posDir.lat,posDir.lng);
					arrowX = arrowEndpoint.x;
					arrowY = arrowEndpoint.y;
				}
				
				var oldGlobalCompositeOperation = null;
				if (color === false) {
					oldGlobalCompositeOperation = ctx.globalCompositeOperation;
					ctx.globalCompositeOperation = 'difference';
					color = '#fff';
				}

				ctx.lineWidth = lineWidth;
				ctx.strokeStyle = color;
				ctx.beginPath();
				ctx.moveTo(coord.x, coord.y);
				ctx.lineTo(arrowX, arrowY);
				ctx.stroke();

				var arrowAngle = 12;
				var arrowLength = Math.round(2*arrowSize / 3);

				ctx.beginPath();
				ctx.moveTo(arrowX, arrowY);
				ctx.lineTo(coord.x + Math.sin(rad(arrowDirection+arrowAngle)) * arrowLength, coord.y - Math.cos(rad(arrowDirection+arrowAngle)) * arrowLength);
				ctx.stroke();

				ctx.beginPath();
				ctx.moveTo(arrowX, arrowY);
				ctx.lineTo(coord.x + Math.sin(rad(arrowDirection-arrowAngle)) * arrowLength, coord.y - Math.cos(rad(arrowDirection-arrowAngle)) * arrowLength);
				ctx.stroke();

				if (elongationPattern!==false && elongationPattern!==null) {
					ctx.setLineDash(elongationPattern);
					ctx.lineWidth = 1;
					ctx.beginPath();
					ctx.moveTo(coord.x, coord.y);
					arrowSize = canvasSize; //TODO: limit to the edge of canvas
					ctx.lineTo(coord.x + Math.sin(rad(arrowDirection)) * arrowSize, coord.y - Math.cos(rad(arrowDirection)) * arrowSize);
					ctx.stroke();
					ctx.setLineDash([]);
				}
				
				if (null!== oldGlobalCompositeOperation) {
					ctx.globalCompositeOperation = oldGlobalCompositeOperation;
				}
			}

			function rad(deg) { return deg * Math.PI * rec180; }

			var difRadLat = null;
			var difRadLng = null;
			var radLat1 = null;
			var radLng1 = null;
			var radLat2 = null;
			var radLng2 = null;
			//http://www.movable-type.co.uk/scripts/latlong.html
			function getAngularDistance(lat1, lng1, lat2, lng2) {
				radLat1 = rad(lat1); //φ1
				radLng1 = rad(lng1); //λ1
				radLat2 = rad(lat2); //φ2
				radLng2 = rad(lng2); //λ2
				difRadLat = radLat2 - radLat1; //Δφ
				difRadLng = radLng2 - radLng1; //Δλ
				var halfChordSquared = Math.sin(difRadLat/2) * Math.sin(difRadLat/2) +
					Math.cos(radLat1) * Math.cos(radLat2) *
					Math.sin(difRadLng/2) * Math.sin(difRadLng/2);
				var result = 2 * Math.atan2(Math.sqrt(halfChordSquared), Math.sqrt(1-halfChordSquared));
				return result;
			}
			function getInitialBearing(lat1, lng1, lat2, lng2) {
				//θ = atan2( sin Δλ ⋅ cos φ2 , cos φ1 ⋅ sin φ2 − sin φ1 ⋅ cos φ2 ⋅ cos Δλ )
				var y = Math.sin(rad(lng2-lng1)) * Math.cos(rad(lat2));
				var x = Math.cos(rad(lat1))*Math.sin(rad(lat2)) - Math.sin(rad(lat1))*Math.cos(rad(lat2))*Math.cos(rad(lng2-lng1));
				return (Math.atan2(y, x)*180/Math.PI + 360) % 360; // in degrees
			}
			function getFracPoint(frac,angDistRad) { //based on the last call of getAngularDistance(), f=0..1
				var A = Math.sin((1-frac)*angDistRad) / Math.sin(angDistRad);
				var B = Math.sin(frac*angDistRad) / Math.sin(angDistRad);

				var x = A * Math.cos(radLat1) * Math.cos(radLng1) + B * Math.cos(radLat2) * Math.cos(radLng2);
				var y = A * Math.cos(radLat1) * Math.sin(radLng1) + B * Math.cos(radLat2) * Math.sin(radLng2);
				var z = A * Math.sin(radLat1) + B * Math.sin(radLat2);

				return {
					lat:m180divPI * Math.atan2(z, Math.sqrt(x*x + y*y)),
					lng:m180divPI * Math.atan2(y, x)
				};
			}

			function isSunVisible(observer,htcOffset,sinDecl,cosDecl) {
				//htcOffset = (h-12)*15 + TC
				//sinDecl = Math.sin(rad(Decl));
				//cosDecl = Math.cos(rad(Decl));
				var SHArto = htcOffset + observer.lng;
				if (SHArto > 180) {
					SHArto = SHArto - 360;
				} else if (SHArto < -180) {
					SHArto = SHArto + 360;
				}

				var cosSZA = Math.sin(rad(observer.lat)) * sinDecl + Math.cos(rad(observer.lat)) * cosDecl * Math.cos(rad(SHArto));
				//cosSZA < 0 = sun is below horizon
				//cosSZA > 0 = sun is visible above horizon
				return cosSZA;
			}

			function getSunPos(sunDate,observer) {
				//https://gist.github.com/jgomezdans/733741/

				year = sunDate.getUTCFullYear();
				var startDate = new Date(Date.UTC(year,0,1,0,0,0));
				var doy = 1 + Math.floor((sunDate - startDate) / (1000 * 60 * 60 * 24));
				var h = sunDate.getUTCHours() + sunDate.getUTCMinutes()/60; //absolute value (not relative to observer)
				var g = (2/365.25)*(doy + h/24)*Math.PI;
				//declination = sun Geographical Position latitude (absolute)
				var Decl = 0.396372-22.91327*Math.cos(g)+4.02543*Math.sin(g)-0.387205*Math.cos(2*g)
					+ 0.051967*Math.sin(2*g)-0.154527*Math.cos(3*g) + 0.084798*Math.sin(3*g);
				//solar angle time correction
				var TC = 0.004297+0.107029*Math.cos(g)-1.837877*Math.sin(g) - 0.837378*Math.cos(2*g) - 2.340475*Math.sin(2*g);
				//Solar Hour Angle relative to observer SHArto = (hour-12)*15 + Longitude + TC
				var htcOffset = (h-12)*15 + TC;
				var SHArto = htcOffset + observer.lng;
				if (SHArto > 180) {
					SHArto = SHArto - 360;
				} else if (SHArto < -180) {
					SHArto = SHArto + 360;
				}
				//absolute SHA = absolute sun Geographical Position longitude
				var SHAa = (12-h)*15 - TC;
				if (SHAa > 180) {
					SHAa = SHAa - 360;
				} else if (SHAa < -180) {
					SHAa = SHAa + 360;
				}
				//zenith (relative to observer)
				//cos(SZA) = sin(Latitude)*sin(Decl)+cos(Latitude)*cos(Decl)*cos(SHA)
				var sinDecl = Math.sin(rad(Decl));
				var cosDecl = Math.cos(rad(Decl));
				var cosSZA = Math.sin(rad(observer.lat)) * sinDecl + Math.cos(rad(observer.lat)) * cosDecl * Math.cos(rad(SHArto));
				//cosSZA < 0 = sun is below horizon
 				if (cosSZA > 1.00) cosSZA = 1.00;
 				if (cosSZA < -1.00) cosSZA = -1.00;
 				var SZArad = Math.acos(cosSZA);
 				var SZA = SZArad * m180divPI; //zenith>90 = sun is below horizon

				//azimuth (relative to observer)
				//cos(AZ) = (sin(Decl)-sin(Latitude)*cos(SZA))/(cos(Latitude)*sin(SZA))
				var cosAZ = (Math.sin(rad(Decl)) - Math.sin(rad(observer.lat)) * Math.cos(SZArad)) / (Math.cos(rad(observer.lat)) * Math.sin(SZArad));
 				if (cosAZ > 1.00) cosAZ = 1.00;
 				if (cosAZ < -1.00) cosAZ = -1.00;
				var AZ = Math.acos(cosAZ) * m180divPI;
				if (SHArto>0) AZ = 360 - AZ; //https://en.wikipedia.org/wiki/Solar_azimuth_angle#Formulas "...between 180 and 360 degrees when the hour angle is positive (afternoon)"

				return {'lat':Decl, 'lng':SHAa, 'az':AZ, 'zen':SZA, 'htcOffset':htcOffset, 'sinDecl':sinDecl, 'cosDecl':cosDecl }; //lat,lng = absolute; az,zen = relative to observer
			}

			//compare to: https://www.timeanddate.com/worldclock/sunearth.html

			function getUTCDateTime(d) {
				year = d.getUTCFullYear();
				return year + '-' + String('0'+(d.getUTCMonth()+1)).slice(-2)
					+ '-' + String('0'+d.getUTCDate()).slice(-2) + ' ' + String('0'+d.getUTCHours()).slice(-2) + ':'
					+ String('0'+d.getUTCMinutes()).slice(-2) + ':' + String('0'+d.getUTCSeconds()).slice(-2);
			}
			function outputUTCDateTime(d) {
				document.getElementById('dateTimeInput').value = getUTCDateTime(d);
				if (ctx!==null) {
					var localDate = new Date(d.getTime() + observerGmtOffset);
					var textOffset = Math.round(canvasSize*0.001);
					var textSize = Math.round(canvasSize*0.08);
					ctx.font = textSize+'px Arial';
					ctx.fillStyle = '#000';
					ctx.fillText(String('0'+localDate.getUTCHours()).slice(-2)+':'+String('0'+localDate.getUTCMinutes()).slice(-2), textOffset, textOffset+textSize);
				}
			}

			function updateAzimuthCheckLink(d, observerGmtOffset) {
				var localDate = new Date(d.getTime() + observerGmtOffset);

				document.getElementById('azimuthCheckLink').href = 'https://www.suncalc.org/#/'
					+ (Math.round(userLat*10000)/10000) + ',' + (Math.round(userLng*10000)/10000) + ',2/'
					+ localDate.getUTCFullYear()+'.'+String('0'+(localDate.getUTCMonth()+1)).slice(-2)+'.'+String('0'+localDate.getUTCDate()).slice(-2)
					+ '/' + String('0'+localDate.getUTCHours()).slice(-2) + ':' + String('0'+localDate.getUTCMinutes()).slice(-2) + '/1/0';
			}

			function showAltSunPos(sunDate) {
				var altPos = [
					{'pos':{'lat':0.0,'lng':-150},'cat':0},
					{'pos':{'lat':0.0,'lng':-120},'cat':0},
					{'pos':{'lat':0.0,'lng':-90},'cat':0},
					{'pos':{'lat':0.0,'lng':-60.0},'cat':0},
					{'pos':{'lat':0.0,'lng':-30.0},'cat':0},
					{'pos':{'lat':0.0,'lng':0.0},'cat':0},
					{'pos':{'lat':0.0,'lng':30.0},'cat':0},
					{'pos':{'lat':0.0,'lng':60.0},'cat':0},
					{'pos':{'lat':0.0,'lng':90},'cat':0},
					{'pos':{'lat':0.0,'lng':120.0},'cat':0},
					{'pos':{'lat':0.0,'lng':150.0},'cat':0},
					{'pos':{'lat':0.0,'lng':180},'cat':0},

					{'pos':{'lat':-60.0,'lng':-150},'cat':-60},
					{'pos':{'lat':-60.0,'lng':-120},'cat':-60},
					{'pos':{'lat':-60.0,'lng':-90},'cat':-60},
					{'pos':{'lat':-60.0,'lng':-60.0},'cat':-60},
					{'pos':{'lat':-60.0,'lng':-30.0},'cat':-60},
					{'pos':{'lat':-60.0,'lng':0.0},'cat':-60},
					{'pos':{'lat':-60.0,'lng':30.0},'cat':-60},
					{'pos':{'lat':-60.0,'lng':60.0},'cat':-60},
					{'pos':{'lat':-60.0,'lng':90},'cat':-60},
					{'pos':{'lat':-60.0,'lng':120.0},'cat':-60},
					{'pos':{'lat':-60.0,'lng':150.0},'cat':-60},
					{'pos':{'lat':-60.0,'lng':180},'cat':-60},

					{'pos':{'lat':60.0,'lng':-150},'cat':60},
					{'pos':{'lat':60.0,'lng':-120},'cat':60},
					{'pos':{'lat':60.0,'lng':-90},'cat':60},
					{'pos':{'lat':60.0,'lng':-60.0},'cat':60},
					{'pos':{'lat':60.0,'lng':-30.0},'cat':60},
					{'pos':{'lat':60.0,'lng':0.0},'cat':60},
					{'pos':{'lat':60.0,'lng':30.0},'cat':60},
					{'pos':{'lat':60.0,'lng':60.0},'cat':60},
					{'pos':{'lat':60.0,'lng':90},'cat':60},
					{'pos':{'lat':60.0,'lng':120.0},'cat':60},
					{'pos':{'lat':60.0,'lng':150.0},'cat':60},
					{'pos':{'lat':60.0,'lng':180},'cat':60},

					//{'pos':{'lat':,'lng':},'cat':''},
					//{'pos':{'lat':,'lng':},'cat':''},
					//{'pos':{'lat':,'lng':},'cat':''},
					//{'pos':{'lat':,'lng':},'cat':''},
					//{'pos':{'lat':,'lng':},'cat':''},
					//{'pos':{'lat':,'lng':},'cat':''},
					//{'pos':{'lat':-31.95,'lng':115.86},'cat':'Perth'},
					//{'pos':{'lat':40.72,'lng':-74.0},'cat':'New York'},
					//{'pos':{'lat':51.51,'lng':-0.13},'cat':'London'}
				];
				for (var i in altPos) {
					if (
						(altPos[i].cat == 0 && showEquatorCheckpoints) ||
						(altPos[i].cat == -60 && showSouthCheckpoints) ||
						(altPos[i].cat == 60 && showNorthCheckpoints)
					) {
						var altSunPos = getSunPos(sunDate,altPos[i].pos);
						if (altSunPos.zen > 100) { //sun below horizon (>90 + padding)
							//drawCompassGps(altPos[i].pos.lat, altPos[i].pos.lng, '#000', 8, 1);
						} else { //sun above horizon
							drawArrow(altPos[i].pos.lat, altPos[i].pos.lng, altSunPos.az, 1, 20, '#000', [2,10]);
							//drawCompassGps(altPos[i].pos.lat, altPos[i].pos.lng, '#000', 8, 1);
						}
					}

				}

			}
			
			function drawSkyHorizon() {
				if (null === topCtx) return false;
				topCtx.clearRect(0, 0, topCtx.canvas.width, topCtx.canvas.height);
				if (
					!showSkyHorizon ||
					!showObserver ||
					userLat === 'NaN' ||
					userLng === 'NaN'
				) return false;
				
				var tileSize = 2;
				var halfTileSize = 1;
				var angDist = 0;
				var fillAlpha;
				var maxAlpha = 0.94;
				var gradFrom = 1.55; //PI/2 = 1.5708; refraction = 0.01 at the horizon
				var gradTo = 1.604;
				var gradDif = gradTo - gradFrom;
				var cnt = 0;
				for (var x=0; x<canvasSize; x+=tileSize) {
					for (var y=0; y<canvasSize; y+=tileSize) {
						pos = xyToGps(x,y);
						angDist = getAngularDistance(pos.lat, pos.lng, userLat, userLng);
						if (angDist > gradFrom) { 
							fillAlpha = maxAlpha;
							if (angDist < gradTo) {
								fillAlpha = maxAlpha*(angDist-gradFrom)/gradDif;
							}
							topCtx.fillStyle = "rgba(255,255,255,"+fillAlpha+")";
							topCtx.beginPath();
							topCtx.rect(x-halfTileSize, y-halfTileSize, tileSize, tileSize);
							topCtx.fill();
							cnt++;
						}
					}
				}
				//console.log('drew '+cnt+' tiles');
			}

			function drawNight(htcOffset, sinDecl, cosDecl) {
				if (ctx===null) return false;
				//isSunVisible(testPosition, htcOffset, sinDecl, cosDecl);

				//canvasRadius = canvasSize/2;
				//canvasRadiusSquared = canvasSize*canvasSize/4;
				var tileSize = 6;
				var halfTileSize = 3;
				var visibility = -1;
				var pos = false;
				var drawNightSegment = false;
				var fillAlpha = 1;

				for (var x=0; x<canvasSize; x+=tileSize) {
					for (var y=0; y<canvasSize; y+=tileSize) {
						pos = xyToGps(x,y);
						if (pos !== false) {
							visibility = isSunVisible(pos, htcOffset, sinDecl, cosDecl);
							drawNightSegment = true;
							//ctx.globalAlpha = 1;
							fillAlpha = 1;
							if (visibility > 0.1) {
								drawNightSegment = false;
								//if (visibility > 0.85) {
								//	ctx.globalAlpha = (visibility-0.84)*2;
								//	ctx.fillStyle = '#ff0';
								//	ctx.beginPath();
								//	ctx.rect(x-halfTileSize, y-halfTileSize, tileSize, tileSize);
								//	ctx.fill();
								//}
							} else if (visibility > -0.2) {
								fillAlpha = 1-(visibility+0.2)*3.33;
								//ctx.globalAlpha = fillAlpha;
							}

							if (drawNightSegment) {
								//ctx.fillStyle = '#000';
								ctx.fillStyle = "rgba(0,0,0,"+fillAlpha+")";
								ctx.beginPath();
								ctx.rect(x-halfTileSize, y-halfTileSize, tileSize, tileSize);
								ctx.fill();
							}
						}
					}
				}
				//ctx.globalAlpha = 1;
			}
			//------------------------------------------------------------------
			
			function setUserPos(lat,lng) {
				if (
					typeof lat === 'undefined' || lat === null ||
					typeof lat === 'undefined' || lat === null
				) {
					navigator.geolocation.getCurrentPosition(function(position) {
						if (
							!isNaN(position.coords.latitude) && 
							!isNaN(position.coords.longitude) &&
							position.coords.latitude !== 'NaN' && 
							position.coords.longitude !== 'NaN' &&
							position.coords.latitude !== null &&
							position.coords.longitude !== null
						) {
							setUserPos(position.coords.latitude, position.coords.longitude);
							setTimeout('redraw();',10);
						}
					},function(){ //geolocation unavailable
						setUserPos(previousLat, previousLng);
						setTimeout('redraw();',10);
					});
				} else {
					userLat = Math.round(lat*10000)/10000;
					userLng = Math.round(lng*10000)/10000;
					if (
						!isNaN(userLat) && !isNaN(userLng) &&
						userLat !== 'NaN' && userLng !== 'NaN'
					) {
						document.getElementById('latLongInput').value = (userLat) + ', ' + (userLng);
						document.getElementById('latLongInput').style.backgroundColor = '#fff';
						if (
							typeof Celestial2nd.location === 'function' &&
							showStars && showLocalView
						) Celestial2nd.location([userLat,userLng]);
					}
				}
			}

			function redraw(allowAnimation) {
				if (ctx===null) return false;
				if (typeof allowAnimation === 'undefined' || true !== allowAnimation) allowAnimation = false;
				if (!allowAnimation && doAnimateTime) return;

				if (animateTimeout!==null) clearTimeout(animateTimeout);

				//ctx.fillStyle = '#fff';
				ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
				
				

				var parsedUserLocation = /^(-?[0-9]+(?:.[0-9]+)?)[\s,;]+(-?[0-9]+(?:.[0-9]+)?)$/.exec(document.getElementById('latLongInput').value);
				if (
					//typeof parsedUserLocation != 'null' &&
					typeof parsedUserLocation != 'undefined' &&
					parsedUserLocation != null &&
					//parsedUserLocation != false &&
					'1' in  parsedUserLocation &&
					'2' in  parsedUserLocation &&
					typeof parsedUserLocation[1] != 'undefined' &&
					typeof parsedUserLocation[2] != 'undefined' &&
					'NaN' != parseFloat(parsedUserLocation[1]) &&
					'NaN' != parseFloat(parsedUserLocation[2])
				) {
					setUserPos(parsedUserLocation[1],parsedUserLocation[2]);
					
				} else {
					//alert('unknown GPS format, use -12.34, 56.78');
					document.getElementById('latLongInput').style.backgroundColor = '#fcc';
				}

				var parsedDate = /^([0-9]{4})[-]([0-9]{1,2})[-]([0-9]{1,2})(?:[ ]([0-9]{1,2})[:]([0-9]{1,2})(?:[:]([0-9]{1,2}))?)?$/.exec(document.getElementById('dateTimeInput').value);
				if (
					typeof parsedDate != 'undefined' &&
					parsedDate != null &&
					'1' in parsedDate &&
					'2' in parsedDate &&
					'3' in parsedDate &&
					typeof parsedDate[1] != 'undefined' &&
					typeof parsedDate[2] != 'undefined' &&
					typeof parsedDate[3] != 'undefined' &&
					'NaN' != parseInt(parsedDate[1]) &&
					'NaN' != parseInt(parsedDate[2]) &&
					'NaN' != parseInt(parsedDate[3])
				) {
					if (!('4' in parsedDate) || typeof parsedDate[4] == 'undefined' || 'NaN'==parseInt(parsedDate[4])) parsedDate[4] = 0;
					if (!('5' in parsedDate) || typeof parsedDate[5] == 'undefined'  || 'NaN'==parseInt(parsedDate[5])) parsedDate[5] = 0;
					if (!('6' in parsedDate) || typeof parsedDate[6] == 'undefined'  || 'NaN'==parseInt(parsedDate[6])) parsedDate[6] = 0;

					jsDate = new Date(Date.UTC(
						parseInt(parsedDate[1]),
						parseInt(parsedDate[2])-1,
						parseInt(parsedDate[3]),
						parseInt(parsedDate[4]),
						parseInt(parsedDate[5]),
						parseInt(parsedDate[6]),
					));
				}

				if (jsDate === null || jsDate == 'Invalid Date' || jsDate == 'NaN') { //use current time if no valid value entered
					jsDate = new Date(); //browser datetime in the timezone of the browser
					observerGmtOffset = jsDate.getTimezoneOffset()*60000;
					//console.log('using browser time');
				}

				outputUTCDateTime(jsDate);

				//console.log(jsDate);
				//console.log(jsDate.toUTCString());
				//console.log(jsDate.getTimezoneOffset());

				if (showStars) { //------------------------------------------------------------------------- show stars
				
					document.getElementById('celestialDiv').style.display = 'block';
					if (showLocalView) document.getElementById('localView').style.display = 'block';
					
					if (!celestialInitialised) {
						//console.log('initialising Celestial');
						document.getElementById('celestialDiv').style.width = canvasSize+'px';
						Celestial.display(celestialConfig);
						
						//console.log('no co?');
						Celestial.resize({width:canvasSize});
						
						for (var i=180;i<4000;i=i*2) setTimeout(function(){ Celestial.date(jsDate); },i); //sometimes the objects don't get rendered if called too soon


						celestialInitialised = true;
					}
					if (!localCelestialInitialised && showLocalView) {
						//console.log('resizing localView to ',localCelestialDivSize);
						document.getElementById(localCelestialDivId).style.height = localCelestialDivSize+'px';
						document.getElementById(localCelestialDivId).style.width = localCelestialDivSize+'px';
						document.getElementById('localView').style.width = localCelestialDivSize+'px';
						localCelestialConfig.geopos = [userLat,userLng];
						localCelestialConfig.daylight.show = showDaylight;
						Celestial2nd.display(localCelestialConfig);
						//Celestial2nd.location([userLat,userLng]);
						//console.log('resizing celestial2nd to ',localCelestialDivSize);
						Celestial2nd.resize({width:localCelestialDivSize});
						Celestial2nd.date(jsDate);
						localCelestialInitialised = true;
					}
					//Celestial.rotate({center:[0,90,celestialViewOrientation]}); //maybe this will be needed?
					//Celestial.skyview({date:jsDate, location:[90, 0]});

					//TODO: DST (daylight savings time) is breaking the star positions between 25.oct 2020 01:00 and 25.Oct 01:59
					
					//console.log('------------------------------');
					//console.log('calling skyview with timezone = '+celestialViewTimezoneOffset+'-'+(jsDate.getTimezoneOffset())+' and date = ',jsDate);
					//console.log('calling skyview with date = ',jsDate);
					//console.log('('+jsDate.getUTCHours()+':'+jsDate.getUTCMinutes()+' UTC, offset '+jsDate.getTimezoneOffset()+')');
					//Celestial.skyview({date:jsDate, timezone:celestialViewTimezoneOffset-jsDate.getTimezoneOffset()});
					
					
					if (celestialInitialised) {
						//Celestial.skyview({date:jsDate, timezone:-jsDate.getTimezoneOffset()}); //doesn't work a couple of months from 25.oct 2020
						Celestial.skyview({date:jsDate}); //doesn't work between 25.oct 2020 01:00 and 25.Oct 01:59
					}
					if (showLocalView && localCelestialInitialised) {
						Celestial2nd.skyview({date:jsDate});
					}

					/*
					Celestial.container.selectAll('.planet').each(function(obj) {
						var id = obj.id();
						if (id=='sol') {
							var dt = Celestial.date(), o = Celestial.origin(dt).spherical();
							var p = obj(dt).equatorial(o);
							//var pt = Celestial.prjMap(p.pos);
							//console.log(p);
						}
					});/* */
					//Celestial.skyview({date:jsDate, location:[0, 90]});
				}


				var sunPos = getSunPos(jsDate,{'lat':userLat,'lng':userLng});
				if (showDaylight) {
					drawNight(sunPos.htcOffset, sunPos.sinDecl, sunPos.cosDecl);
				} else {
					//darken the whole map so stars are visible
					ctx.fillStyle = '#000';
					var halfCanvas = Math.round(canvasSize/2);
					ctx.beginPath();
					ctx.arc(halfCanvas, halfCanvas, halfCanvas, 0, 2*Math.PI, true);
					ctx.fill();
				}
				
				drawMap();
				drawSun(sunPos.lat, sunPos.lng);

				if (sunPos.lat != 'NaN' && sunPos.lng != 'NaN')
					document.getElementById('latLongOutput').value = Math.round(sunPos.lat*10000)/10000 + ', ' + Math.round(sunPos.lng*10000)/10000;
				if (sunPos.zen != 'NaN' && sunPos.az != 'NaN')
					document.getElementById('zenAzOutput').value = Math.round(sunPos.zen*10000)/10000 + ', ' + Math.round(sunPos.az*10000)/10000;
				if (showObserver) {
					if (sunPos.zen > 100) { //sun below horizon (>90 + padding)
						drawCompassGps(userLat, userLng, '#000', 13, 2);
						document.getElementById('dayCaption').style.display = 'none';
						document.getElementById('nightCaption').style.display = 'inline';
					} else { //sun above horizon
						drawArrow(userLat, userLng, sunPos.az, 3, 50, '#f32', [8,4]);
						drawCompassGps(userLat, userLng, '#000', 13, 2);
						document.getElementById('dayCaption').style.display = 'inline';
						document.getElementById('nightCaption').style.display = 'none';
					}
				} else {
					document.getElementById('dayCaption').style.display = 'none';
					document.getElementById('nightCaption').style.display = 'none';
				}
				if (showFlatDirection) {
					drawArrow(userLat, userLng, sunPos, 1, 0, '#090', false);
				}

				showAltSunPos(jsDate);

				document.getElementById('sunPosCheckLink').href = 'https://www.timeanddate.com/worldclock/sunearth.html?month='
					+ (jsDate.getUTCMonth()+1) + '&day=' + jsDate.getUTCDate() + '&year=' + jsDate.getUTCFullYear() + '&hour='
					+ jsDate.getUTCHours() + '&min=' + jsDate.getUTCMinutes() + '&ntxt=London';

				if (
					Math.round(1000*previousLat)/1000 != Math.round(1000*userLat)/1000 ||
					Math.round(1000*previousLng)/1000 != Math.round(1000*userLng)/1000
				) {
					document.getElementById('azimuthCheckLink').href = 'https://www.suncalc.org/';
					if (goingToRequest) {
						clearTimeout(requestWaitTimeout);
						goingToRequest = false;
					}
					if (!doAnimateTime) { //prevent spamming the service
						goingToRequest = true;
						requestWaitTimeout = setTimeout(function(){
							goingToRequest = false;
							var xhr = new XMLHttpRequest();
							xhr.onload = function() {
								if (this.readyState == 4 && this.status == 200) {
									var jsonData = JSON.parse(this.responseText);
									if ('status' in jsonData && jsonData.status=='OK' && 'gmtOffset' in jsonData) {
										observerGmtOffset = jsonData.gmtOffset*1000; //eg. GMT+1 -> jsonData.gmtOffset = 3600
	
										updateAzimuthCheckLink(jsDate, observerGmtOffset);
	
									} else {
										//sometimes timezone is not found (for example in the ocean)
									}
								} else { alert('requesting timezonedb.com failed'); }
								previousLat = userLat; previousLng = userLng;
							};
							var timeZoneDbUrl = 'https://api.timezonedb.com/v2.1/get-time-zone?key=H57PYG9KKM6P&format=json&by=position&lat='
								+ (Math.round(userLat*10000)/10000) + '&lng=' + (Math.round(userLng*10000)/10000);
	
							xhr.open('get', timeZoneDbUrl);
							xhr.send();
						},1200);
					}
					
				} else {
					updateAzimuthCheckLink(jsDate, observerGmtOffset)
				}
				
				if (ctx!==null && previewLat!==null && previewLng!==null) {
					drawCompassGps(previewLat,previewLng,'#e00',11,2,false);
					/*
					ctx.fillStyle = '#f00';
					ctx.beginPath();
					previewCoord = gpsToMapXY(previewLat,previewLng);
					ctx.lineWidth = 1;
					ctx.arc(previewCoord.x, previewCoord.y, 2, 0, 2*Math.PI, true); //3rd param = radius
					ctx.strokeStyle = '#f00';
					ctx.stroke();
					ctx.fill(); /* */
				}
				
				if (userLat!==oldHorizonLat || userLng!==oldHorizonLng) {
					drawSkyHorizon();
					oldHorizonLat = userLat;
					oldHorizonLng = userLng;
				}

				if (doAnimateTime) {
					advanceAnimation(animateTimeInterval*animTimeFactor);
					//jsDate = new Date(jsDate.getTime() + animateTimeInterval*animTimeFactor); //add animateTimeInterval milliseconds
					//outputUTCDateTime(jsDate);
					if (animateTimeout!==null) clearTimeout(animateTimeout);
					animateTimeout = setTimeout('redraw(true);',animateTimePeriod);
				}
			} //redraw
			
			function advanceAnimation(deltaTime) {
				if (typeof deltaTime === 'undefined' || deltaTime === null) {
					deltaTime = animateTimeInterval*animTimeFactor;
				}
				jsDate = new Date(jsDate.getTime() + deltaTime);
				outputUTCDateTime(jsDate);
			}
			
			//------------------------------------------------------------------
			
			function setAnimationSpeed(sliderValue) {
				if (sliderValue === oldAnimationSpeedSlider) return false;
				//animateTimeInterval in milliseconds
				animateTimeInterval = Math.round(179*sliderValue*sliderValue + 151.6*sliderValue + 9680);
				oldAnimationSpeedSlider = sliderValue;
				//console.log(sliderValue, animateTimeInterval);
			}

			function setMarchEquinox() {
				document.getElementById('dateTimeInput').value = year+'-03-20 03:00';
				setTimeout('redraw();',10);
				return false;
			}
			function setJuneSolstice() {
				document.getElementById('dateTimeInput').value = year+'-06-20 20:00';
				setTimeout('redraw();',10);
				return false;
			}
			function setSeptemberEquinox() {
				document.getElementById('dateTimeInput').value = year+'-09-22 05:00';
				setTimeout('redraw();',10);
				return false;
			}
			function setDecemberSolstice() {
				document.getElementById('dateTimeInput').value = year+'-12-21 05:00';
				setTimeout('redraw();',10);
				return false;
			}
			function setMonth(monthNumber) {
				if (monthNumber < 10) monthNumber = '0'+monthNumber;
				document.getElementById('dateTimeInput').value = document.getElementById('dateTimeInput').value.replace(/^([0-9]+[-])[0-9]+([-].+)$/,'$1'+monthNumber+'$2');
				setTimeout('redraw();',10);
				return false;
			}
			//------------------------------------------------------------------


			//------------------------------------------------------------------
			function resizeCanvas() {
				canvasSize = window.innerHeight-6;
				if (window.innerWidth < canvasSize) canvasSize = window.innerWidth-6;
				halfCanvas = Math.round(canvasSize/2);
				canvasSizeReciprocal = 1/canvasSize;
				//document.getElementById('mainContainer').style.width = (localViewLeftOffset+canvasSize)+'px';
				document.getElementById('canvasDiv').style.width = canvasSize+'px';
				document.getElementById('controlsDiv').style.left = canvasSize+'px';
				document.getElementById('topDiv').style.width = canvasSize+'px';
				document.getElementById('localView').style.left = (localViewLeftOffset+canvasSize)+'px';
				localCelestialDivSize = window.innerWidth-canvasSize-localViewLeftOffset-12;
				if (window.innerHeight-12 < localCelestialDivSize) localCelestialDivSize = window.innerHeight-12;
				if (halfCanvas < localCelestialDivSize) localCelestialDivSize = halfCanvas;
				if (localCelestialDivSize < 200) localCelestialDivSize = 200;
				if (showStars) {
					Celestial.resize({width:canvasSize});
					document.getElementById('celestialDiv').style.width = canvasSize+'px';
					if (showLocalView) {
						//console.log('resizing localView to ',localCelestialDivSize);
						document.getElementById(localCelestialDivId).style.height = localCelestialDivSize+'px';
						document.getElementById(localCelestialDivId).style.width = localCelestialDivSize+'px';
						document.getElementById('localView').style.width = localCelestialDivSize+'px';
						//console.log('resizing celestial2nd to ',localCelestialDivSize);
						Celestial2nd.resize({width:localCelestialDivSize});
					}
				}
				
				if (ctx!==null) {
					ctx.canvas.width = canvasSize;
					ctx.canvas.height = canvasSize;
				}
				if (topCtx!==null) {
					topCtx.canvas.width = canvasSize;
					topCtx.canvas.height = canvasSize;
					drawSkyHorizon();
				}
				redraw();
			}

			//------------------------------------------------------------------
			var previousWindowHeight = 0;
			var previousWindowWidth = 0;
			function resizeHandler() {
				if (
					Math.abs(previousWindowHeight-window.innerHeight) > 0 ||
					Math.abs(previousWindowWidth-window.innerWidth) > 0
				) {
					previousWindowHeight = window.innerHeight;
					previousWindowWidth = window.innerWidth;

					resizeCanvas();
				}
			}//resizeHandler


			//------------------------------------------------------------------
			function showDistanceOnCanvas(startX,startY,endX,endY) {
				redraw();
				//calculate flatearth-straight-looking path distance
				var stepX = (endX - startX);
				var stepY = (endY - startY);
				var stepCount = (Math.abs(stepX) + Math.abs(stepY));
				stepX = stepX / stepCount;
				stepY = stepY / stepCount;
				var oldPosX = startX;
				var oldPosY = startY;
				var oldCoord = xyToGps(oldPosX,oldPosY);
				var aeDist = 0;

				for (var i=0; i<stepCount; i++) {

					var newPosX = oldPosX + stepX;
					var newPosY = oldPosY + stepY;
					var newCoord = xyToGps(newPosX,newPosY);
					drawDot(newCoord.lat, newCoord.lng, 2, '#d0c');
					aeDist+= 6371*getAngularDistance(oldCoord.lat, oldCoord.lng, newCoord.lat, newCoord.lng);
					oldPosX = newPosX;
					oldPosY = newPosY;
					oldCoord = newCoord;
				}
				document.getElementById('aeDistance').style.fontWeight = 'bold';
				document.getElementById('aeDistance').innerText = Math.round(aeDist)+' km';
				//document.getElementById('aeDistanceTooltip').innerText = Math.round(aeDist)+' km';
				
				//calculate pixel distance ("FE" distance based on meridian distances)
				var feDist = Math.sqrt((endX-startX)*(endX-startX)+(endY-startY)*(endY-startY)) / (canvasSize) * 40008;
				document.getElementById('feDistance').style.fontWeight = 'bold';
				document.getElementById('feDistance').innerText = Math.round(feDist)+' FE km';

				//calculate globe great circle route
				var radAd = getAngularDistance(routeStartLat, routeStartLng, routeEndLat, routeEndLng);
				document.getElementById('gcDistance').style.paddingLeft = '15px';
				document.getElementById('gcDistance').style.fontWeight = 'bold';
				document.getElementById('gcDistance').innerText = Math.round(radAd*6371)+' km';
				//document.getElementById('gcDistanceTooltip').innerText = Math.round(radAd*6371)+' km';

				drawDot(routeStartLat,routeStartLng, 2, '#0b0');

				var fracStep = canvasSizeReciprocal/radAd;

				for (var frac = fracStep; frac < 0.999999; frac += fracStep) {
					var fracPoint = getFracPoint(frac,radAd);
					drawDot(fracPoint.lat, fracPoint.lng, 2, '#0b0');
				}
				drawDot(routeEndLat, routeEndLng, 2, '#0b0');
			}

			function hideDistanceGpsModal() {
				showDistanceGpsModal=false;
				document.getElementById('distanceGpsModal').style.display='none';
			}
			function showDistanceGps() {
				if (
					isNaN(parseFloat(document.getElementById('distLat1').value)) ||
					parseFloat(document.getElementById('distLat1').value) < -90 ||
					parseFloat(document.getElementById('distLat1').value) > 90
				) {
					document.getElementById('distLat1').focus();
					return false;
				} else {
					routeStartLat = parseFloat(document.getElementById('distLat1').value);
				}
				if (isNaN(parseFloat(document.getElementById('distLng1').value))) {
					document.getElementById('distLng1').focus();
					return false;
				} else {
					routeStartLng = parseFloat(document.getElementById('distLng1').value);
				}

				if (
					isNaN(parseFloat(document.getElementById('distLat2').value)) ||
					parseFloat(document.getElementById('distLat2').value) < -90 ||
					parseFloat(document.getElementById('distLat2').value) > 90
				) {
					document.getElementById('distLat2').focus();
					return false;
				} else {
					routeEndLat = parseFloat(document.getElementById('distLat2').value);
				}
				if (isNaN(parseFloat(document.getElementById('distLng2').value))) {
					document.getElementById('distLng2').focus();
					return false;
				} else {
					routeEndLng = parseFloat(document.getElementById('distLng2').value);
				}
				var routeStartXY = gpsToMapXY(routeStartLat,routeStartLng);
				var routeEndXY = gpsToMapXY(routeEndLat,routeEndLng);
				showDistanceOnCanvas(routeStartXY.x,routeStartXY.y,routeEndXY.x,routeEndXY.y);
				
				
				routeStartLat = null; routeStartLng = null;
			}

			function hideDateTimeSelector() {
				dateTimeSelectorHideTimeout = null;
				document.getElementById('dateTimeSelector').style.display = 'none';
			}
				
			function hideLocationSelector() {
				locationSelectorHideTimeout = null;
				document.getElementById('locationSelector').style.display = 'none';
				previewLat = null;
				previewLng = null;
				redraw();
			}
			
			function populateLocationSelector() {
				var ls = document.getElementById('locationSelector');
				var idCnt = 0;
				var cityElement = null;
				for (var i in citiesGps) {
					cityElement = document.createElement('DIV');
					cityElement.innerText = citiesGps[i][0];
					cityElement.id = 'ls'+idCnt;
					cityElement.style.display = 'block';
					//cityElement.style.cursor = 'inherit';
					ls.appendChild(cityElement);
					(function(cityLat,cityLng){
						cityElement.addEventListener('click', function(event) {
							document.getElementById('latLongInput').style.backgroundColor = '#fff';
							document.getElementById('latLongInput').value = cityLat+', '+cityLng;
							previewLat = null;
							previewLng = null;
							redraw();
						});	
						cityElement.addEventListener('mouseover', function(event) {
							previewLat = cityLat;
							previewLng = cityLng;
							//console.log('set preview to ',previewLat,previewLng);
							redraw();
						});	
					})(citiesGps[i][1],citiesGps[i][2]);
					
					
					//TODO: show cities on map on hover
					
					locationSelectorElements.push([idCnt,citiesGps[i][0],citiesGps[i][1],citiesGps[i][2]]);
					idCnt++;
				}
				//console.log('done populating location selector');
			}
			function locationSelectorSearch(val) {
				//document.getElementById('locationSelector').style.cursor = 'wait';
				//document.getElementById('locationSelector').className = 'searchInProgress';
				//document.getElementById('latLongInput').style.cursor = 'wait';
				if (previewLat !== null || previewLng !== null) {
					previewLat = null;
					previewLng = null;
					redraw();
				}
				
				if (val!=='') {
					//search
					//[ 0: element id number, 1: city name, 2: lat, 3: lng ]
					var cntAll = 0;
					var cntFound = 0;
					var cntHidden = 0;
					for (var i in locationSelectorElements) {
						cntAll++;
						if (locationSelectorSearchAbort) return false;
						if (-1 < locationSelectorElements[i][1].toLowerCase().indexOf(val)) {
							document.getElementById('ls'+locationSelectorElements[i][0]).style.display = 'block';
							cntFound++;
						} else {
							(function(cityDiv){
								setTimeout(function(){
									document.getElementById(cityDiv).style.display = 'none';
								},1);
							})('ls'+locationSelectorElements[i][0]);
							cntHidden++;
						}
						//if (cntFound > 33 || document.getElementById('locationSelector').scrollHeight > 500) {
							//document.getElementById('locationSelector').style.overflow = 'auto';
						//}
					}
					//console.log('search finished',cntAll,cntFound,cntHidden);
					//console.log(document.getElementById('locationSelector').scrollHeight);
				} else {
					for (var i in locationSelectorElements) {
						document.getElementById('ls'+locationSelectorElements[i][0]).style.display = 'block';
					}
				}
				//document.getElementById('locationSelector').style.cursor = 'default';
				document.getElementById('locationSelector').className = '';
				document.getElementById('latLongInput').style.cursor = 'default';
				document.getElementById('locationSelector').style.display = 'block';
			}
			
			function localViewDocker() {
				localViewDocked = !localViewDocked;
				localViewLeftOffset = localViewDocked ? 0 : localViewUndockedOffset;
				document.getElementById('localViewDocker').innerHTML = localViewDocked ? 'undock &raquo;' : '&laquo; dock';
				document.getElementById('controlsDiv').style.display = localViewDocked ? 'none' : 'block';
				resizeCanvas();
			}

			//------------------------------------------------------------------ LOAD --------------------------

			function load() {
				window.setTimeout('populateLocationSelector();',200);
				
				document.getElementById('dockerDiv').style.display = showDockerDiv ? 'block' : 'none';
			
				if (null !== document.getElementById('canvasMap'))
					ctx = document.getElementById('canvasMap').getContext('2d');
				if (null !== document.getElementById('canvasTop'))
					topCtx = document.getElementById('canvasTop').getContext('2d');

				//tooltipStyle = document.getElementById('tooltip').style;
				document.getElementById('animateCheckbox').addEventListener('change', function(event) {
					if (doAnimateTime) {
						doAnimateTime = false;
						if (animateTimeout!==null) {
							clearTimeout(animateTimeout);
							animateTimeout = null;
						}
					} else {
						doAnimateTime = true;
						if (animateTimeout!==null) clearTimeout(animateTimeout);
						animateTimeout = setTimeout('redraw(true);',animateTimePeriod);
					}
				});
				document.getElementById('animateBackwards').addEventListener('change', function(event) {
					animTimeFactor = -animTimeFactor;
				});

				setAnimationSpeed(document.getElementById('animationSpeed').value);

				if (null!==document.getElementById('daylightCheckbox'))
					document.getElementById('daylightCheckbox').checked = showDaylight;

				document.getElementById('celestialDiv').style.display = (showStars)?'block':'none';
				document.getElementById('localView').style.display = (showStars && showLocalView)?'block':'none';
				if (null!==document.getElementById('skyHorizonCheckbox')) {
					document.getElementById('skyHorizonCheckbox').checked = showSkyHorizon;
				}
				if (null!==document.getElementById('starsCheckbox')) {
					document.getElementById('starsCheckbox').checked = showStars;
					document.getElementById('starsCheckbox').addEventListener('change', function(event) {
						if (showStars) {
							showStars = false;
							document.getElementById('celestialDiv').style.display = 'none';
							document.getElementById('localView').style.display = 'none';
						} else {
							showStars = true;
							//celestialDiv will be set to display=block in redraw() after datetime setting
						}
						redraw();
					});
				}

				document.getElementById('dateTimeInput').addEventListener('keyup', function(event) {
					event.preventDefault();
					if (event.keyCode === 13) {
						setTimeout('redraw();',10);
					}
				});
				document.getElementById('showObserver').checked = showObserver;

				if (document.getElementById('canvasTop')!==null) {

					document.getElementById('canvasTop').addEventListener('click', function(event) { //mousedown
						var userPos = xyToGps(event.clientX, event.clientY);
						if (userPos !== false) {
							setUserPos(userPos.lat, userPos.lng);
							setTimeout('redraw();',10);
						}
					}, false);
					document.getElementById('canvasTop').addEventListener('mousemove', function(event) {
						var mousePos = xyToGps(event.clientX, event.clientY);
						if (mousePos !== false && routeStartLat !== null && routeStartLng !== null) {
							//tooltipStyle.top = (event.clientY + 17)+'px';
							//tooltipStyle.left = (event.clientX + 9)+'px';

							routeEndLat = mousePos.lat;
							routeEndLng = mousePos.lng;
							document.getElementById('distLat2').value = Math.round(mousePos.lat*10000)/10000;
							document.getElementById('distLng2').value = Math.round(mousePos.lng*10000)/10000;
							var routeStartXY = gpsToMapXY(routeStartLat,routeStartLng);
							showDistanceOnCanvas(routeStartXY.x,routeStartXY.y,event.clientX,event.clientY);
							drawArrow(routeStartLat,routeStartLng,getInitialBearing(routeStartLat,routeStartLng,routeEndLat,routeEndLng),3,40,false);

						}
					}, false);
					document.getElementById('canvasTop').addEventListener('contextmenu', function(event) {
						var clickPos = xyToGps(event.clientX, event.clientY);
						if (clickPos !== false) {

							if (routeStartLat !== null && routeStartLng !== null) {
								document.getElementById('distLat2').value = Math.round(clickPos.lat*10000)/10000;
								document.getElementById('distLng2').value = Math.round(clickPos.lng*10000)/10000;

								routeStartLat = null;
								routeStartLng = null;
								//tooltipStyle.display = 'none';
							} else {
								routeStartLat = clickPos.lat;
								routeStartLng = clickPos.lng;
								document.getElementById('distLat1').value = Math.round(routeStartLat*10000)/10000;
								document.getElementById('distLng1').value = Math.round(routeStartLng*10000)/10000;
								drawDot(clickPos.lat, clickPos.lng, 2, '#0b0');
								//tooltipStyle.display = 'block';
							}

						}
						event.preventDefault(); //stop context menu
					}, false);
				} //canvasTop works
					
				document.getElementById('gcDistance').addEventListener('contextmenu', function(event) {
					showDistanceGpsModal = !showDistanceGpsModal;
					if (!showDistanceGpsModal) {
						document.getElementById('distanceGpsModal').style.display='none';
					} else {
						document.getElementById('distanceGpsModal').style.display='block';
						if (null!==routeStartLat) document.getElementById('distLat1').value = Math.round(routeStartLat*10000)/10000;
						if (null!==routeStartLng) document.getElementById('distLng1').value = Math.round(routeStartLng*10000)/10000;
						if (null!==routeEndLat) document.getElementById('distLat2').value = Math.round(routeEndLat*10000)/10000;
						if (null!==routeEndLng) document.getElementById('distLng2').value = Math.round(routeEndLng*10000)/10000;
					}
					event.preventDefault(); //stop context menu
				}, false);
				document.getElementById('distLat1').addEventListener('keyup', function(event) {
					if (event.key === 'Enter') showDistanceGps();
				});
				document.getElementById('distLng1').addEventListener('keyup', function(event) {
					if (event.key === 'Enter') showDistanceGps();
				});
				document.getElementById('distLat2').addEventListener('keyup', function(event) {
					if (event.key === 'Enter') showDistanceGps();
				});
				document.getElementById('distLng2').addEventListener('keyup', function(event) {
					if (event.key === 'Enter') showDistanceGps();
				});
				
				//--------------------------------------------------------------- location selector
				
				function locationSearch(query) {
					query = query.toLowerCase();
					if (locationSearchLast === query) return false;
					locationSelectorSearchAbort = true;
					document.getElementById('locationSelector').className = 'searchInProgress';
					document.getElementById('latLongInput').style.cursor = 'wait';
					if (null!==locationSelectorSearchTimeout) window.clearTimeout(locationSelectorSearchTimeout);
					locationSelectorSearchTimeout = window.setTimeout(function() {
						locationSearchLast = query;
						locationSelectorSearchTimeout = null;
						locationSelectorSearchAbort = false;
						locationSelectorSearch(query);
					},150);
				}
				document.getElementById('latLongInput').addEventListener('keyup', function(event) {
					event.preventDefault();
					
					document.getElementById('latLongInput').style.backgroundColor = '#fff';
					if (RegExp('^[a-zA-Z ]*$').test(document.getElementById('latLongInput').value)) {
						locationSearch(document.getElementById('latLongInput').value);
					}
					if (event.keyCode === 13) {
						setTimeout('redraw();',10);
					}
				});
				document.getElementById('locationSearch').addEventListener('keyup', function(event) {
					event.preventDefault();
					locationSearch(document.getElementById('locationSearch').value);
				});
				
				document.getElementById('latLongInput').addEventListener('mouseover', function(event) {
					if (null!==locationSelectorHideTimeout) window.clearTimeout(locationSelectorHideTimeout);
					document.getElementById('locationSelector').style.display = 'block';
				});
				document.getElementById('latLongInput').addEventListener('mouseout', function(event) {
					if (null!==locationSelectorHideTimeout) window.clearTimeout(locationSelectorHideTimeout);
					locationSelectorHideTimeout = setTimeout('hideLocationSelector();',300);
				});
				document.getElementById('locationSelector').addEventListener('mouseover', function(event) {
					if (null!==locationSelectorHideTimeout) window.clearTimeout(locationSelectorHideTimeout);
				});
				document.getElementById('locationSelector').addEventListener('mouseout', function(event) {
					if (null!==locationSelectorHideTimeout) window.clearTimeout(locationSelectorHideTimeout);
					locationSelectorHideTimeout = setTimeout('hideLocationSelector();',300);
				});
				
				//-------------------------------------------------------------- time selector
				document.getElementById('dateTimeInput').addEventListener('mouseover', function(event) {
					if (null!==dateTimeSelectorHideTimeout) window.clearTimeout(dateTimeSelectorHideTimeout);
					document.getElementById('dateTimeSelector').style.display = 'block';
				});
				document.getElementById('dateTimeInput').addEventListener('mouseout', function(event) {
					if (null!==dateTimeSelectorHideTimeout) window.clearTimeout(dateTimeSelectorHideTimeout);
					dateTimeSelectorHideTimeout = setTimeout('hideDateTimeSelector();',300);
				});
				document.getElementById('dateTimeSelector').addEventListener('mouseover', function(event) {
					if (null!==dateTimeSelectorHideTimeout) window.clearTimeout(dateTimeSelectorHideTimeout);
				});
				document.getElementById('dateTimeSelector').addEventListener('mouseout', function(event) {
					if (null!==dateTimeSelectorHideTimeout) window.clearTimeout(dateTimeSelectorHideTimeout);
					dateTimeSelectorHideTimeout = setTimeout('hideDateTimeSelector();',300);
				});


				resizeCanvas();

				//--------------------------------------------------------------

				redraw();


				//------------------- celestial debug -------------------------

				celestialConfig = {
					zoomlevel: 0.511,
					geopos: [90,90], //lat,lon
					//settimezone: false, //prevent DST glitching
					projection: "azimuthalEquidistant",
					//center: [90,90,celestialViewOrientation],       // Initial center coordinates in equatorial transformation [hours (lon), degrees (lat), degrees],
					//follow: 'center', //with this enabled the sky doesn't rotate when changing the datetime
					//orientationfixed: true,  // Keep orientation angle the same as center[2]
					background: { fill: "#fff", stroke: "#fff", opacity: 0.01, width: 0.01, },
					//adaptable: true,    // Sizes are increased with higher zoom-levels
					interactive: false,  // Enable zooming and rotation with mousewheel and dragging
					form: false,        // Display settings form
					location: false,
					controls: false,     // Display zoom controls
					container: "celestialDiv",   // ID of parent element, e.g. div
					datapath: "celestialdata/",  // Path/URL to data files, empty = subfolder 'data'
					stars: {
						show: true,
						names: false,
						limit: 4.6
					},
					dsos: {show: false},
					mw: { show: false},
					constellations: {
						show: true,
						names: true,
						//lineStyle: { stroke: "#cccccc", width: 1.5, opacity: 0.6, 
						//lineStyle: { stroke: "#f22", width: 1.5, opacity: 0.6, 
						//	highlightId: 'Oct',
						//	highlightStyle: { stroke: "#f22", width: 2.5, opacity: 1 },
						//},
						//bounds: true,
						//boundStyle: { stroke: "#cccc00", width: 0.5, opacity: 0.8, dash: [2, 4] }
					},
					horizon: { show: false },
					daylight: { show: false },
					lines: {
						graticule: { show: false },
						equatorial: { show: false, stroke: "#9a8", width: 1.3, opacity: 0.7 },
						ecliptic: { show: true, stroke: "#66cc66", width: 1.1, opacity: 0.4, dash: [5, 4] },
					},
	
					/* */
					planets: {
						show: true,
						which: ["sol", "mer", "ven", "ter", "lun", "mar", "jup", "sat", "ura", "nep"],
						symbolStyle: { fill: "#00ccff", font: "bold 17px 'Lucida Sans Unicode', Consolas, sans-serif", align: "center", baseline: "middle" },
						symbols: {  // Character and color for each symbol in 'which', simple circle \u25cf
							"sol": {symbol: "\u2609", fill: "#ffff00"},
							"mer": {symbol: "\u263f", fill: "#cccccc"},
							"ven": {symbol: "\u2640", fill: "#eeeecc"},
							"ter": {symbol: "\u2295", fill: "#00ffff"},
							"lun": {symbol: "\u25cf", fill: "#ffffff", size:18}, // overridden by generated cresent
							"mar": {symbol: "\u2642", fill: "#ff9999"},
							"cer": {symbol: "\u26b3", fill: "#cccccc"},
							"ves": {symbol: "\u26b6", fill: "#cccccc"},
							"jup": {symbol: "\u2643", fill: "#ff9966"},
							"sat": {symbol: "\u2644", fill: "#ffcc66"},
							"ura": {symbol: "\u2645", fill: "#66ccff"},
							"nep": {symbol: "\u2646", fill: "#6666ff"},
							"plu": {symbol: "\u2647", fill: "#aaaaaa"},
							"eri": {symbol: "\u25cf", fill: "#eeeeee"}
						},
						
						//symbolStyle: { fill: "#00ccff", font: "bold 17px 'Lucida Sans Unicode', Consolas, sans-serif", align: "center", baseline: "middle" },
						//symbolType: "symbol",  // Type of planet symbol: 'symbol' graphic planet sign, 'disk' filled circle scaled by magnitude
						// 'letter': 1 or 2 letters S Me V L Ma J S U N
						//names: false,          // Show name in nameType language next to symbol
						//nameStyle: { fill: "#00ccff", font: "14px 'Lucida Sans Unicode', Consolas, sans-serif", align: "right", baseline: "top" },
						//namesType: "desig"     // Language of planet name (see list below of language codes available for planets),
						// or desig = 3-letter designation
						
					}, /* */
				}; //celestialConfig

				/* */
				localCelestialConfig = {
					zoomlevel: 1,
					//geopos: [-33.92, 151.1852], //lat,lon sydney
					geopos: [userLat, userLng],
					settimezone: false,

					width: localCelestialDivSize+'px',     // Default width, 0 = full parent width; height is determined by projection
					projection: "azimuthalEquidistant",  // Map projection used: airy, aitoff, armadillo, august, azimuthalEqualArea, azimuthalEquidistant, baker, berghaus, boggs, bonne, bromley, collignon, craig, craster, cylindricalEqualArea, cylindricalStereographic, eckert1, eckert2, eckert3, eckert4, eckert5, eckert6, eisenlohr, equirectangular, fahey, foucaut, ginzburg4, ginzburg5, ginzburg6, ginzburg8, ginzburg9, gringorten, hammer, hatano, healpix, hill, homolosine, kavrayskiy7, lagrange, larrivee, laskowski, loximuthal, mercator, miller, mollweide, mtFlatPolarParabolic, mtFlatPolarQuartic, mtFlatPolarSinusoidal, naturalEarth, nellHammer, orthographic, patterson, polyconic, rectangularPolyconic, robinson, sinusoidal, stereographic, times, twoPointEquidistant, vanDerGrinten, vanDerGrinten2, vanDerGrinten3, vanDerGrinten4, wagner4, wagner6, wagner7, wiechel, winkel3
					//transform: "equatorial", // Coordinate transformation: equatorial (default), ecliptic, galactic, supergalactic
					//center: [90,90,celestialViewOrientation],       // Initial center coordinates in equatorial transformation [hours, degrees, degrees],
						// otherwise [degrees, degrees, degrees], 3rd parameter is orientation, null = default center
					orientationfixed: true,  // Keep orientation angle the same as center[2]
					
					background: { fill: "#000", stroke: "#000", opacity: 1, width: 1, },
					//adaptable: true,    // Sizes are increased with higher zoom-levels
					interactive: false,  // Enable zooming and rotation with mousewheel and dragging
					form: false,        // Display settings form
					location: false,    // Display location settings
					controls: false,     // Display zoom controls
					//lang: "",           // Language for names, so far only for constellations: de: german, es: spanish
								// Default:en or empty string for english
					container: localCelestialDivId,   // ID of parent element, e.g. div
					datapath: "celestialdata/",  // Path/URL to data files, empty = subfolder 'data'
					stars: {
						show: true,
						names: false,
						limit: 4.6
					},
					planets: {
						show: true,
						which: ["sol", "mer", "ven", "ter", "lun", "mar", "jup", "sat", "ura", "nep"],
						symbolStyle: { fill: "#00ccff", font: "bold 17px 'Lucida Sans Unicode', Consolas, sans-serif", align: "center", baseline: "middle" },
						symbols: {  // Character and color for each symbol in 'which', simple circle \u25cf
							"sol": {symbol: "\u2609", fill: "#ffff00"},
							"mer": {symbol: "\u263f", fill: "#cccccc"},
							"ven": {symbol: "\u2640", fill: "#eeeecc"},
							"ter": {symbol: "\u2295", fill: "#00ffff"},
							"lun": {symbol: "\u25cf", fill: "#ffffff", size:16}, // overridden by generated cresent
							"mar": {symbol: "\u2642", fill: "#ff9999"},
							"cer": {symbol: "\u26b3", fill: "#cccccc"},
							"ves": {symbol: "\u26b6", fill: "#cccccc"},
							"jup": {symbol: "\u2643", fill: "#ff9966"},
							"sat": {symbol: "\u2644", fill: "#ffcc66"},
							"ura": {symbol: "\u2645", fill: "#66ccff"},
							"nep": {symbol: "\u2646", fill: "#6666ff"},
							"plu": {symbol: "\u2647", fill: "#aaaaaa"},
							"eri": {symbol: "\u25cf", fill: "#eeeeee"}
						}
					},
					
					dsos: {show: false},
					mw: { show: false},
					constellations: {
						show: true,
						names: true,
					},
					horizon: { show: true },
					daylight: { show: showDaylight },
					lines: {
						graticule: { show: false },
						equatorial: { show: false },
						ecliptic: { show: false },
					},
				}; //localCelestialConfig
				//Celestial2nd.display(localCelestialConfig);

			} //load()
			
			function localRotate(orientation) {
				var center = Celestial2nd.rotate();
				center[2] = orientation;
				Celestial2nd.rotate({center:center});
			}
			
		</script>
	</head>
	<body onload="load();" onresize="setTimeout('resizeHandler();',10);">
		<img id="mapimg" src="gleasonmap.jpg" style="display:none;" />
		<div id="mainContainer" style="padding:0px; margin:0px;">
			<div id="canvasDiv" style="float:left; padding:0px; margin:0px; display:block;"><canvas id="canvasMap"></canvas></div>
			<div id="celestialDiv" style="position:absolute; padding:0px; margin:0px; display:block;"></div>
			<div id="topDiv" style="position:absolute; padding:0px; margin:0px; display:block;"><canvas id="canvasTop"></canvas></div>
			<div id="controlsDiv" style="position:absolute; left:300px; top:0px; padding:0px; margin:0px; width:200px; display:block;">
				<input type="checkbox" id="showObserver" checked="checked" onchange="showObserver = !showObserver; redraw();" />
				<label for="showObserver">Observer location:</label><br />
				<input type="text" id="latLongInput" tabindex="1" value="0.00, 0.00" style="width:130px" />
				<button onclick="setTimeout('redraw();',10);">GO</button><br />
				<div id="locationSelector" style="position:absolute; width:185px; max-height:340px; 
					overflow:auto; background:#bbb; display:none; z-index:5;">
					<button onclick="setUserPos();" style="width:85px; padding:0px;">get local</button><br />
					<input type="text" id="locationSearch" placeholder="search" style="width:140px;" /><br /><br />
				</div>
				<input type="checkbox" id="equatorCheckpoints" onchange="showEquatorCheckpoints = !showEquatorCheckpoints; redraw();" />
				<label for="equatorCheckpoints"> Equator Checkpoints</label><br />
				<input type="checkbox" id="northCheckpoints" onchange="showNorthCheckpoints = !showNorthCheckpoints; redraw();" />
				<label for="northCheckpoints"> North Checkpoints</label><br />
				<input type="checkbox" id="southCheckpoints" onchange="showSouthCheckpoints = !showSouthCheckpoints; redraw();" />
				<label for="southCheckpoints"> South Checkpoints</label><br />
				<input type="checkbox" id="flatDirection" onchange="showFlatDirection = !showFlatDirection; redraw();" />
				<label for="flatDirection"> flatearth direction to Sun</label><br />
				<br />

				<input type="checkbox" id="starsCheckbox" title="stars, planets and constellations" />
				<label for="starsCheckbox" title="stars, planets and constellations">sky</label>
				<input type="checkbox" id="daylightCheckbox" 
					title="Earth surface daylight"
					onchange="showDaylight = !showDaylight; if (localCelestialInitialised) Celestial2nd.apply({daylight: { show: showDaylight }}); redraw();" />
				<label for="daylightCheckbox" title="Earth surface daylight">day</label>
				<input type="checkbox" id="skyHorizonCheckbox" 
					title="sky horizon relative to observer position" 
					onchange="showSkyHorizon = !showSkyHorizon; drawSkyHorizon();" />
				<label for="skyHorizonCheckbox" title="sky horizon relative to observer position">sky horizon</label>
				<br />

				<input type="checkbox" id="animateCheckbox" /><label for="animateCheckbox">animate</label>
				(<input type="checkbox" id="animateBackwards" /><label for="animateBackwards">back</label>)
				speed:
				<br />
				<input type="range" id="animationSpeed" min="1" max="200" value="5"
					onchange="setAnimationSpeed(this.value);" oninput="setAnimationSpeed(this.value);" />
				<br />
					
				
				Greenwich London time (UTC)<br />
				<input type="text" id="dateTimeInput" value="" style="width:130px" /><button onclick="setTimeout('redraw();',10);">set</button><br />
				<div id="dateTimeSelector" style="position:absolute; width:160px; height:90px; 
					background:#ccc; border:solid 1px black; padding:3px; display:none; z-index:4;">
					<a href="#" onclick="return setMonth(1);">Jan</a>
					<a href="#" onclick="return setMonth(2);">Feb</a>
					<a href="#" onclick="return setMonth(3);">Mar</a>
					<a href="#" onclick="return setMonth(4);">Apr</a>
					<a href="#" onclick="return setMonth(5);">May</a>
					<a href="#" onclick="return setMonth(6);">Jun</a><br />
					<a href="#" onclick="return setMonth(7);">Jul</a>
					<a href="#" onclick="return setMonth(8);">Aug</a>
					<a href="#" onclick="return setMonth(9);">Sep</a>
					<a href="#" onclick="return setMonth(10);">Oct</a>
					<a href="#" onclick="return setMonth(11);">Nov</a>
					<a href="#" onclick="return setMonth(12);">Dec</a><br />
					<a href="#" onclick="return setMarchEquinox();">March equinox</a><br />
					<a href="#" onclick="return setJuneSolstice();">June solstice</a><br />
					<a href="#" onclick="return setSeptemberEquinox();">September equinox</a><br />
					<a href="#" onclick="return setDecemberSolstice();">December solstice</a><br />
				</div>
	
				<span id="gcDistance" style="font-size:12px; color:#080; padding-left:4px;">right-click to measure distance</span>
				 / <span id="aeDistance" style="font-size:12px; color:#b08;"></span><br />
				 <span id="feDistance" style="font-size:12px; color:#008;"></span>
				<div id="distanceGpsModal" style="display:none; border:solid 1px black; padding:6px; line-height:25px;
					font-size:12px; text-align:center; width:180px; background-color:#ffc; position:absolute; z-index:3;">
					measure distance between:<br />
					<label for="distLat1">lat:</label><input type="text" id="distLat1" style="width:60px;" />&nbsp;
					<label for="distLng1">lon:</label><input type="text" id="distLng1" style="width:60px;" /><br />
					<label for="distLat2">lat:</label><input type="text" id="distLat2" style="width:60px;" />&nbsp;
					<label for="distLng2">lon:</label><input type="text" id="distLng2" style="width:60px;" /><br />

					<button onclick="document.getElementById('distLat1').value = userLat;
						document.getElementById('distLng1').value = userLng;
						routeStartLat = userLat; routeStartLng = userLng;" 
						style="width:80px;" title="measure distance from observer location">from obs.</button>
					<button onclick="document.getElementById('distLat2').value = userLat;
						document.getElementById('distLng2').value = userLng;
						routeEndLat = userLat; routeEndLng = userLng;" 
						style="width:80px;" title="measure distance to observer location">to obs.</button>
					<br />
					<button onclick="showDistanceGps();" style="width:60px;">GO</button>
					<button onclick="hideDistanceGpsModal();" style="width:60px;">hide</button>
				</div>
				<br />
				<br />

				Sun pos:<br />
				<input type="text" id="latLongOutput" value="" readonly="readonly" style="width:105px" />
				<a id="sunPosCheckLink" href="https://www.timeanddate.com/worldclock/sunearth.html" 
					target="_blank">(check<img src="external.svg" width="10" height="10" />)</a><br />
				Zenith, azimuth:<br />
				<input type="text" id="zenAzOutput" value="0.00, 0.00" readonly="readonly" style="width:105px" />
				<a id="azimuthCheckLink" href="https://suncalc.org/" 
					target="_blank">(check<img src="external.svg" width="10" height="10" />)</a><br />
				<b id="dayCaption" style="color:#c00;">Red arrow = which direction is the Sun visible on the sky</b>
				<b id="nightCaption" style="display:none;">The Sun is not visible from observer location</b><br /><br />
				<ul id="footerLinks">
				<li><a href="https://www.metabunk.org/direction-to-sun-vs-sun-position-above-the-ae-map-visualization.t10401/">metabunk discussion thread</a></li>
				<li><a href="https://github.com/oudeicrat/oudeicrat.github.io/issues">report problems, ask questions</a></li>
				<li><a href="https://github.com/ofrohn/d3-celestial">stars projection library</a></li>
				<li><a href="https://mctoon.net/">MC Toon's excellent flat earth debunking resources</a></li>
				<li><a href="https://flatearth.ws/">another great flat earth annihilating web</a></li>
				<li><a href="https://flatearthlunacy.com/">more thorough flat earth destruction</a></li>
				</ul><br />
				<div id="debug"></div>
			</div>
		</div>
		<div id="localView" style="position:absolute; top:0px; left:0px; width:100px; height:100px; display:none;"
			onclick="localViewDocker();">
			<div id="dockerDiv" style="border:solid 1px black; background-color:#ddd; text-align:center;">
				local sky view from the ground 
				<button id="localViewDocker" onclick="localViewDocker(); event.stopPropagation();">&laquo; dock</button>
			</div>
			<div style="font-weight:bolder; text-align:center;">N</div>
			<div id="localCelestialDiv" style="margin:0px; padding:0px; margin:0px;"></div>
			<div style="font-weight:bolder; text-align:center;">S</div>
		</div>
		<div style="position:absolute; bottom:0px; right:0px; width:200px; height:200px; background-color:red; display:none;"
			onclick="advanceAnimation(20*60*1000); redraw();"></div>
		<!--div id="tooltip" style="position:absolute; top:0px; left:0px; display:none; width:140px; background-color:white;">
			<span id="gcDistanceTooltip" style="font-size:12px; color:#080;"></span>
			 / <span id="aeDistanceTooltip" style="font-size:12px; color:#b08;"></span>
		</div-->
	</body>
</html>
